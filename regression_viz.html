<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Regression Micrograd</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        #reporting-container {
            font-size: 16px;
            line-height: 1.5;
            font-family: 'Courier New', Courier, monospace;
            padding: 20px;
        }

        .loss-display {
            display: flex;
        }

        .loss-label {
            width: 250px;
            /* Adjust this value as needed */
        }

        #main-container {
            display: flex;
            width: 100%;
            height: 700px;
        }

        #svg-container {
            flex: 0 0 1200px;
            z-index: 10;
            /* overflow: auto; */
        }

        #right-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #info-container {
            /* flex: 1; */
            min-height: 350px;
            padding: 15px;
            overflow-y: auto;
        }

        .container {
            display: flex;
            justify-content: center;
        }

        #controls {
            padding: 0 20px;
        }

        #bottom-right-container {
            flex: 1;
            padding: 15px 20px;
            overflow-y: visible;
        }

        #info {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            line-height: 1.5;

            height: 250px;
            border-radius: 15px;
            overflow-y: auto;

        }

        #info .katex {
            font-size: 1.2em;
        }

        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        /* MLP CSS*/
        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        #network {
            border: 1px solid #ccc;
        }

        #layerDimInput {
            width: 75px;
            font-size: 16px;
            font-weight: 500;
            border: 0;
            background-color: #dbf4ff33;
        }

        #layerDimInput:hover {
            outline: 1px solid navy;
        }

        .data-params-input {
            width: 35px;
            font-size: 16px;
            font-weight: 500;
            border: 0;
            background-color: #dbf4ff33;
        }

        .data-params-input:hover {
            outline: 1px solid navy;
        }

        .layer:hover rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.1;
        }

        .latex-label:hover {
            filter: brightness(0.5);
        }

        .latex-label.selected {
            filter: brightness(0.5);
        }

        .layer.selected>rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.3;
        }

        /* Connections */
        .connection:hover {
            stroke-width: 4;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));
        }

        .connection.positive {
            stroke: rgb(100, 100, 255);
        }

        .connection.negative {
            stroke: rgb(255, 100, 100);
        }

        .connection.selected {
            stroke-width: 3;
            stroke-opacity: 1;
        }

        /* Nodes */
        .node {
            cursor: pointer;
        }

        .node:hover {
            fill: #ffb650;
        }

        .node.selected {
            fill: #ffb650;
        }

        /* MLP actions */
        #button-group-container {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        #button-group {
            display: flex;
            align-items: center;
        }

        #button-group button {
            margin: 0 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #btn-edit-dims {
            margin: 0 10px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            /* border: 1px solid rgba(0, 0, 128, 0.4); */
            border: 0;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #button-group .large-button {
            font-size: 24px;
            width: 50px;
            height: 50px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
        }


        #button-group .small-button {
            font-size: 18px;
            padding: 8px 16px;
            width: 50px;
            height: 40px;
        }

        #button-group button:hover,
        #btn-edit-dims:hover {
            background-color: #e0f1f2;
        }

        #button-group button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #eee;
        }

        /* Data plot */
        #data-visualization {
            margin-top: 30px;
        }

        #data-plot {
            border: 1px solid #ccc;
        }

        .data-point {
            stroke-width: 2;
            fill: none;
        }

        .data-point.hit {
            fill-opacity: 0.3;
        }

        /* .data-point.train {} */

        .data-point.val {
            stroke: #999;
            stroke-width: 2;
        }

        .data-point.miss {
            fill-opacity: 1;
        }

        .label-missing {
            fill: gray;
            fill-opacity: 1;
        }

        .regression {
            fill: navy;
        }

        .label-0 {
            fill: navy;
        }

        .label-1 {
            fill: gold;
        }

        .label-2 {
            fill: red;
        }

        .prediction-line {
            pointer-events: none;
        }
    </style>
    <!-- for LaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <!-- for anim -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <!-- for plotting data -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        HTML
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <div id="main-container">
        <div id="svg-container">
            <svg id="network" width="1200" height="700"></svg>
        </div>
        <div id="right-container">
            <div id="info-container">
                <div id="info"></div>
                <div id="button-group-container">
                    <div id="button-group">
                        <button id="btn-reset-mlp" class="small-button">↺</button>
                        <button id="btn-play-pause" class="large-button">
                            <span id="btn-play-pause-content">▶</span>
                        </button>
                        <button id="btn-step" class="small-button">▶|</button>
                        <button id="btn-fwd-backprop-update" class="small-button">→</button>
                    </div>
                </div>
            </div>
            <div id="bottom-right-container">
                <div id="controls">
                    <span id="w-label"></span><input type="text" id="w-input" class="data-params-input">
                    <span id="b-label"></span><input type="text" id="b-input" class="data-params-input">
                    <span>noise = </span><input type="text" id="noise-input" class="data-params-input">
                    <button id="btn-edit-dims" onclick="resetData()">Regenerate data</button>
                </div>
                <div class="container">
                    <div id="data-visualization">
                        <!-- <svg id="data-plot" width="380" height="380"></svg> -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="reporting-container">
        <div id="log-container"></div>
    </div>



    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Javascript
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <script>
        // globals
        let mlp;
        let layerDims;
        let train_split, val_split, test_split;
        let predsTrain, predsVal;

        let isRunningOptimization = false;
        let epoch = 0;

        let currentTrainingStage = 0; // 0: forward, 1: backward, 2: update
        let maxStrength = 0.001;
        let maxGradient = 0.001;

        // Linear Regression
        let w_pred = 1;
        let b_pred = 0;
        let w_true = -2;
        let b_true = 3;
        let noiseScale = 5;

        // AdamW
        let learning_rate = 1e-1;
        let beta1 = 0.9;
        let beta2 = 0.95;
        let weight_decay = 1e-4;
        const eps = 1e-8;

        const infoElement = document.getElementById('info');

        let selectedElement = null;
        const svgNetwork = document.getElementById('network');

        let svgWidth = 1200;
        let svgHeight = 700;

        const valInterval = 10; // interval for calculating validation loss

        const LATEX_FONT_SIZE = 16;
        const LATEX_COLOR = '#999';
        const LATEX_COLOR_LOSS = '#666';
        const layerColors = {
            x: {
                shape: "#ccc",
                overlay: "rgba(204, 204, 204, 0.1)"
            },
            fc: {
                // keep layer display minimaly white for now
                shape: '#FFFFFF',
                overlay: "rgba(255, 255, 255, 0.2)"
            },
            y: {
                shape: "#ccc",
                overlay: "rgba(204, 204, 204, 0.1)"
            },
            bias: {
                shape: "#999",
            }
        };

        // Global variables for D3.js plot
        let svg, x, y, xAxis, yAxis, scatter;
        let currentTransform = d3.zoomIdentity;


        function getLayerColor(layerIndex) {
            if (layerIndex === 0) return layerColors.x;
            if (layerIndex === layerDims.length) return layerColors.y;
            return layerColors.fc;
        }


        function resetAdamMLP() {
            for (const p of mlp.parameters()) {
                p.m = 0.0;
                p.v = 0.0;
            }
        }

        function resetData() {
            w_true = parseFloat(document.getElementById('w-input').value);
            b_true = parseFloat(document.getElementById('b-input').value);
            noiseScale = parseFloat(document.getElementById('noise-input').value);
    

            [train_split, val_split, test_split] = gen_data_linear_regression(random, 100);
            epoch = 0;
            predsTrain = [];
            predsVal = [];
            updateDataPlot();
        }



        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw the MLP
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawNetwork() {
            svgNetwork.innerHTML = '';
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw nodes
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawNode(x, y, layerIndex, nodeIndex, parent, isBiasNode = false) {
            const r = 10;
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            const shapeColor = isBiasNode ? layerColors.bias.shape : getLayerColor(layerIndex).shape
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', isBiasNode ? r / 2 : r);
            circle.setAttribute('fill', shapeColor);
            circle.setAttribute('stroke', 'gray');
            circle.setAttribute('stroke-width', '1');
            circle.classList.add('node');
            circle.dataset.layer = layerIndex;
            circle.dataset.node = nodeIndex;
            parent.appendChild(circle);

            circle.addEventListener('mouseover', showInfo);
            circle.addEventListener('mouseout', clearInfo);
            // circle.addEventListener('click', showInfo);
            circle.addEventListener('mouseenter', handleNodeHover);
            circle.addEventListener('mouseleave', resetConnectionHighlights);
        }

        function drawBiasNode(x, y, layerIndex, parent) {
            drawNode(x, y, layerIndex, layerDims[layerIndex], parent, true);
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw connections
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawConnections(layerIndex, layerXCoord, layerGap) {
            const currentLayer = mlp.layers[layerIndex];
            const currentLayerSize = currentLayer.neurons.length;
            const maxOpacity = 1;

            for (let i = 0; i < currentLayerSize; i++) {
                const neuron = currentLayer.neurons[i];
                let toY = (i + 1) * (svgHeight / (currentLayerSize + 2));
                if (layerIndex == layerDims.length - 2) {
                    // y_hat, no bias
                    toY = (i + 1) * (svgHeight / (currentLayerSize + 1));
                }
                // these weights project backward, meaning they describe how these neurons
                // connect to the previous layers nodes
                const neuronWeights = neuron.parameters()
                const prevLayerSize = neuronWeights.length

                for (let j = 0; j < prevLayerSize; j++) {
                    const fromY = (j + 1) * (svgHeight / (prevLayerSize + 1));
                    const weight = neuronWeights[j];

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', layerXCoord);
                    line.setAttribute('y1', fromY);
                    line.setAttribute('x2', layerXCoord + layerGap);
                    line.setAttribute('y2', toY);
                    line.setAttribute('stroke', '#999');
                    line.setAttribute('stroke-width', '1');

                    const strength = weight.data;
                    const opacity = Math.min(Math.abs(strength) / maxStrength, maxOpacity);
                    line.setAttribute('stroke-opacity', opacity);

                    line.classList.add('connection');
                    line.dataset.from = `${layerIndex},${j}`;
                    line.dataset.to = `${layerIndex + 1},${i}`;
                    line.dataset.strength = strength.toFixed(4);
                    line.dataset.gradient = weight.grad.toFixed(4);

                    svgNetwork.appendChild(line);

                    line.addEventListener('mouseover', showInfo);
                    line.addEventListener('mouseout', (event) => {
                        clearInfo(event);
                        resetConnectionAppearance(event);
                    });
                }
            }
        }


        function drawYConnections(layerIndex, x, layerGap) {
            const currentLayer = layerDims[layerIndex];

            for (let i = 0; i < currentLayer; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', (i + 1) * (svgHeight / (currentLayer + 1)));
                line.setAttribute('x2', x + layerGap);
                line.setAttribute('y2', (i + 1) * (svgHeight / (currentLayer + 1)));
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('stroke-dasharray', '5,5');

                line.classList.add('connection');
                line.dataset.from = `${layerIndex},${i}`;
                line.dataset.to = `${layerIndex + 1},${i}`;
                svgNetwork.appendChild(line);

                line.addEventListener('mouseover', showInfo);
                line.addEventListener('mouseout', clearInfo);
                line.addEventListener('click', showInfo);
            }
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw data points (d3.js)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function initializeD3Plot() {
            const margin = { top: 10, right: 30, bottom: 30, left: 60 };
            const width = 450 - margin.left - margin.right;
            const height = 380 - margin.top - margin.bottom;

            // Append the SVG object to the data-visualization div
            svg = d3.select("#data-visualization")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add X axis
            x = d3.scaleLinear()
                .domain([-15, 15])
                .range([0, width]);
            xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y axis
            y = d3.scaleLinear()
                .domain([-15, 15])
                .range([height, 0]);
            yAxis = svg.append("g")
                .call(d3.axisLeft(y));

            // Add grid line at x = 0
            svg.append("line")
                .attr("class", "grid-line vertical")
                .attr("x1", x(0))
                .attr("y1", 0)
                .attr("x2", x(0))
                .attr("y2", height)
                .attr("stroke", "#ddd")
                .attr("stroke-dasharray", "4");

            // Add grid line at y = 0
            svg.append("line")
                .attr("class", "grid-line horizontal")
                .attr("x1", 0)
                .attr("y1", y(0))
                .attr("x2", width)
                .attr("y2", y(0))
                .attr("stroke", "#ddd")
                .attr("stroke-dasharray", "4");


            // Add a clipPath to ensure that elements are only visible within a specific area
            svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            scatter = svg.append('g')
                .attr("clip-path", "url(#clip)");

            // Add zoom capabilities
            const zoom = d3.zoom()
                .scaleExtent([0.8, 10])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all") // IMPORTANT allow panning and zoom
                .style("cursor", "move")
                .lower() // IMPORTANT Move this rect to the back to capture on hover effects for data points
                .call(zoom);
        }

        function updateChart(event) {
            currentTransform = event.transform;
            // Recover new scale
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            // Update axes
            xAxis.call(d3.axisBottom(newX));
            yAxis.call(d3.axisLeft(newY));

            // Update vertical grid line (x = 0)
            svg.select(".grid-line.vertical")
                .attr("x1", newX(0))
                .attr("x2", newX(0));

            // Update horizontal grid line (y = 0)
            svg.select(".grid-line.horizontal")
                .attr("y1", newY(0))
                .attr("y2", newY(0));


            // Update circle positions
            scatter.selectAll("circle")
                .attr('cx', d => newX(d[0]))
                .attr('cy', d => newY(d[1]));

            // Update true line
            const lineData = [
                { x: newX.domain()[0], y: w_true * newX.domain()[0] + b_true },
                { x: newX.domain()[1], y: w_true * newX.domain()[1] + b_true }
            ];

            const line = d3.line()
                .x(d => newX(d.x))
                .y(d => newY(d.y));

            scatter.select(".true-line")
                .datum(lineData)
                .attr("d", line);

            // Update predicted line
            drawPredictedLine(newX, newY);


        }

        function updateDataPlot() {
            currentTransform = d3.zoomIdentity;
            // Clear existing content
            scatter.selectAll("*").remove();

            // Plot training data
            plotDataPointsRegression(train_split, predsTrain, true);

            // Plot validation data
            plotDataPointsRegression(val_split, predsVal, false);

            // Draw the true line
            drawTrueLine();

            // Draw the predicted line
            drawPredictedLine(x, y);
        }

        function drawTrueLine() {
            const lineData = [
                { x: x.domain()[0], y: w_true * x.domain()[0] + b_true },
                { x: x.domain()[1], y: w_true * x.domain()[1] + b_true }
            ];

            const line = d3.line()
                .x(d => x(d.x))
                .y(d => y(d.y));

            scatter.append("path")
                .datum(lineData)
                .attr("class", "true-line")
                .attr("fill", "none")
                .attr("stroke", "navy")
                .attr("stroke-width", 3)
                .attr("d", line)
                .on("mouseover", showYTrueInfo)
                .on("mouseout", function () {
                    clearInfo();
                    scatter.selectAll(".dotted-line").remove();
                });
        }

        function drawPredictedLine(xScale, yScale) {
            const lineData = [
                { x: xScale.domain()[0], y: w_pred * xScale.domain()[0] + b_pred },
                { x: xScale.domain()[1], y: w_pred * xScale.domain()[1] + b_pred }
            ];

            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y));

            scatter.selectAll(".predicted-line").remove();
            scatter.append("path")
                .datum(lineData)
                .attr("class", "predicted-line")
                .attr("fill", "none")
                .attr("stroke", "#bbb")
                .attr("stroke-width", 3)
                // .attr("stroke-dasharray", "5,5")
                .attr("d", line)
                .on("mouseover", showYPredInfo)
                .on("mouseout", clearInfo);
        }

        function drawLineToPrediction(xValue, yValue, yPred) {
            // Remove any existing line
            scatter.selectAll(".prediction-line").remove();

            // Use the current transform to scale the coordinates
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            // Draw the line
            scatter.append("line")
                .attr("class", "prediction-line")
                .attr("x1", newX(xValue))
                .attr("y1", newY(yValue))
                .attr("x2", newX(xValue))
                .attr("y2", newY(yPred))
                .attr("stroke", "red")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");
        }



        function showYTrueInfo(event) {
            const content = `The line representing the **true** parameters ($$\\mathbf{w}=${w_true}, \\mathbf{b}=${b_true}$$)
            $$ \\mathbf{y} = \\mathbf{w}x + \\mathbf{b} $$\n$$\\mathbf{y} = ${w_true}x + ${b_true}$$\n
            The full function that generates the data is:
            $$ \\mathbf{y} = \\mathbf{w}x + \\mathbf{b} + U(-${noiseScale},${noiseScale}) $$\n
            where $$U$$ is a function that generates a random number uniformly between $$(-${noiseScale},${noiseScale})$$.`;
            renderInfoContent(infoElement, content);

            // Draw dotted lines
            // drawDottedLines();
        }

        function showYPredInfo(event) {
            const content = `The line representing our current guesses ($$w=${w_pred.toFixed(2)}, b=${b_pred.toFixed(2)}$$)
            $$ \\hat{y} = wx + b $$
            $$\\hat{y} = ${w_pred.toFixed(2)}x + ${b_pred.toFixed(2)}$$`;
            renderInfoContent(infoElement, content);
        }


        function plotDataPointsRegression(dataPoints, predictions, isTrainingSet, r = 5) {
            const className = isTrainingSet ? "train-point" : "val-point";

            scatter.selectAll(`.${className}`)
                .data(dataPoints)
                .join("circle")
                .attr("class", `data-point regression ${isTrainingSet ? 'train' : 'val'}`)
                .attr("cx", d => x(d[0]))
                .attr("cy", d => y(d[1]))
                .attr("r", r)
                .on("mouseover", (event, d) => {
                    showDataPointInfo(event, d);
                })
                .on("mouseout", (event) => {
                    clearInfo();
                    removeLineToPrediction();
                });

        }

        function removeLineToPrediction() {
            scatter.selectAll(".prediction-line").remove();
        }


        function showDataPointInfo(event, d) {
            const [xValue, yValue] = d;
            const y_pred = w_pred * xValue + b_pred;
            const diff = (y_pred - yValue).toFixed(2)
            const loss = (diff ** 2).toFixed(2)
            const content = `**${event.target.classList.contains('train') ? 'Training' : 'Validation'}** Data Point\n
            $$\\mathbf{x} = ${xValue.toFixed(2)}$$
            $$\\mathbf{y} = ${yValue.toFixed(2)}$$
            $$\\hat{y} = ${y_pred.toFixed(2)}$$\n
            Difference: $$\\hat{y} - \\mathbf{y} = ${diff}$$
            Loss: $$(\\hat{y} - \\mathbf{y})^2 = ${loss}$$`;
            renderInfoContent(infoElement, content);

            // Draw the line to prediction
            drawLineToPrediction(xValue, yValue, y_pred);
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Display detailed info top-right
        // 
        // TODO later - selectedElement logic so that a click on an el keeps it in display until next click
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function showInfo(event) {
            const target = event.target;
            let content = '';

            if (target.id === 'btn-play-pause' || target.id === "btn-play-pause-content") {
                if (isRunningOptimization) {
                    content = "Pause optimization";
                } else {
                    content = "Run optimization";
                }
            } else if (target.id === 'btn-fwd-backprop-update') {
                switch (currentTrainingStage) {
                    case 0:
                        content = "**Forward pass**: run inference/prediction on the input data to produce predictions $$\\hat{y}$$ and calculate loss with respect to the true output values $$y$$.";
                        break;
                    case 1:
                        // content = "**Backpropagate gradients**: Use the loss information to calculate gradients for each of the tunable weight parameters $$ W $$, starting at the end of the MLP and using the gradient information from later layers to calculate how much we should change the weights in the earlier layers. We are able to accomplish this using the chain rule from calculus ($$\\dfrac{dL}{dW_{l}} → \\dfrac{dL}{dW_{l-1}} → ... → \\dfrac{dL}{dW_{1}}$$, where $$l$$ is the number of layers in our MLP)";
                        content = "**Backpropagate gradients**: Use the loss information to calculate gradients for each of the tunable weight parameters $$ W $$, starting at the end of the MLP and using the gradient information from later layers to calculate how much we should change the weights in the earlier layers.\n\nWe are able to accomplish this using the chain rule from calculus.";
                        break;
                    case 2:
                        showNetworkGradients();
                        content = "**Update weights**: Use the gradient information to update the weights $$ W $$ of the network based on our optimization algorithm (AdamW in this case) and hyperparameters (e.g. learning rate, weight decay), with the goal of nudging this network towards better predictions of the output given the input.\n\nWe also zeros out the gradients to prepare for the next step.";
                        break;
                }
            } else if (target.id === 'btn-reset-mlp') {
                content = "Reset the network parameters to randomly initialized values based on the Uniform Xavier initialization.";
            } else if (target.id === 'btn-shock-weights') {
                content = `\"Shock\" the weights: perturb the weight parameters by adding a small amount of uniform random noise between $$[-${shockNoiseScale}, ${shockNoiseScale}]$$.`;
            } else if (target.id === 'btn-step') {
                content = "Run one full epoch of the training loop and show network animations illustrating the forward pass, backpropagation of gradients, and update of the weights.";
            } else if (target.id === 'layerDimInput') {
                content = "Enter the dimensions of hidden layers, separated by commas.\n\nInput must be comma-separated integers. Maximum " + MAX_N_LAYERS_HIDDEN + " hidden layers and " + MAX_LAYER_SIZE + " neurons per layer.\n\nFor example, $$16,8$$ creates two hidden layers with 16 and 8 neurons respectively.";
            } else if (target.id === 'btn-edit-dims') {
                content = "Initialize a new network with the given dimensions.\n\nThis will reset all weights and biases to new random values based on the specified layer structure and the Uniform Xavier Initialization.";
            } else if (target.classList.contains('node')) {
                const layerIndex = parseInt(target.dataset.layer);
                const nodeIndex = parseInt(target.dataset.node);
                if (nodeIndex === layerDims[layerIndex] + 1) {
                    content = `Indentity node (the vector $$\\mathbf{1}$$).\n\nIt provides a way to add the bias term as part of the matrix multiplication, instead of seperately.`;
                } else if (layerIndex === 0) {
                    content = `Input feature at index $$${nodeIndex}$$`;
                } else if (layerIndex === layerDims.length - 1) {
                    content = `Output feature at index $$${nodeIndex}$$ for $$\\hat{y}$$`;
                } else if (layerIndex === layerDims.length) {
                    content = `Output feature at index $$${nodeIndex}$$ for $$y$$`;
                } else {
                    content = `Node in fully connected layer ${layerIndex}, index ${nodeIndex}`;
                }
            } else if (target.classList.contains('connection')) {
                const [fromLayer, fromNode] = target.dataset.from.split(',');
                const [toLayer, toNode] = target.dataset.to.split(',');
                const fromLayerIndex = parseInt(fromLayer);
                const toLayerIndex = parseInt(toLayer);
                const fromNodeIndex = parseInt(fromNode);
                const toNodeIndex = parseInt(toNode);


                if (fromLayerIndex === layerDims.length - 1 && toLayerIndex === layerDims.length) {
                    content = `Compare $$\\hat{y}$$ and $$y$$ at feature index ${fromNodeIndex}`;
                } else {
                    const strength = parseFloat(target.dataset.strength);
                    const gradient = parseFloat(target.dataset.gradient);
                    const absGradient = Math.abs(gradient);
                    const gradEpsilon = 0.0001;

                    let color;
                    if (gradient >= 0) {
                        color = `rgba(0, 0, 255, ${absGradient / (maxGradient + gradEpsilon)})`;
                    } else {
                        color = `rgba(255, 0, 0, ${absGradient / (maxGradient + gradEpsilon)})`;
                    }

                    target.style.filter = `drop-shadow(0 0 3px ${color})`;
                    if (strength >= 0) {
                        target.classList.add('positive');
                        target.classList.remove('negative');
                    } else {
                        target.classList.add('negative');
                        target.classList.remove('positive');
                    }
                    if (fromNodeIndex === layerDims[fromLayerIndex] + 1) {
                        content = `Bias term for node $$${toNodeIndex}$$ in layer $$${toLayerIndex}$$.\n\nStrength: $$${strength.toFixed(4)}$$`;
                    } else if (fromNodeIndex === 0) {
                        content = `Connection from node $$${fromNodeIndex}$$ in the input layer to node $$${toNodeIndex}$$ in layer $$${toLayerIndex}$$.\n\nStrength: $$${strength.toFixed(4)}$$`;
                    } else {
                        content = `Connection from node $$${fromNodeIndex}$$ in layer $$${fromLayerIndex}$$ to node $$${toNodeIndex}$$ in layer $$${toLayerIndex}$$.\n\nStrength: $$${strength.toFixed(4)}$$`;
                    }
                    content += `\nGradient: $$${gradient.toFixed(4)}$$`;

                }
            } else if (target.classList.contains('layer') || target.parentElement.classList.contains('layer')) {
                const layer = target.classList.contains('layer') ? target : target.parentElement;
                const layerIndex = parseInt(layer.dataset.layer);
                if (layerIndex === 0) {
                    content = `Input layer, containing $$ ${layerDims[layerIndex]}$$ features`;
                } else if (layerIndex === layerDims.length - 1) {
                    content = `Output layer $$\\hat{y}$$, containing $$ ${layerDims[layerIndex]}$$ features`;
                } else if (layerIndex === layerDims.length) {
                    content = `True values $$y$$, containing $$${layerDims[layerDims.length - 1]}$$ features`;
                } else {
                    content = `Fully connected layer ${layerIndex}, containing $$${layerDims[layerIndex]}$$ nodes`;
                }
            } else if (target.closest('.latex-label')) {
                const latexLabel = target.closest('.latex-label');
                const formula = latexLabel.dataset.latex;
                let explanation = '';

                switch (latexLabel.dataset.info) {
                    case 'x':
                        explanation = "This represents the input to the neural network.\n\nIn this case, it's a 2D array containing the $$x1$$ and $$x2$$ coordinates of each data point.";
                        break;
                    case 'y':
                        explanation = "This is the true label vector, representing the correct classification for the input.\n\nIt's a one-hot encoded with $$3$$s elements, corresponding to the three possible classes.";
                        break;
                    case 'y_hat':
                        explanation = "This is the predicted output of the neural network. It has $$3$$ elements, each representing the network's confidence that the input belongs to one of the three classes.";
                        break;
                    case 'loss':
                        explanation = `This is the loss function, which measures the difference between the predicted output $$\\hat{y}$$ and the true label $$y$$. We use cross-entropy loss for this classification task.\n\nThe goal of training is to minimize this loss, bringing $$\\hat{y}$$ and $$y$$ closer for every input.`;
                        break;
                    default:
                        if (latexLabel.dataset.info.startsWith('W')) {
                            const layerNum = latexLabel.dataset.info.slice(1);
                            explanation = `This represents the weight matrix for layer $$ ${layerNum}$$.`; // TODO more info
                        } else if (latexLabel.dataset.info.startsWith('fc')) {
                            const layerNum = latexLabel.dataset.info.slice(2);
                            explanation = `This represents the operation in fully connected layer $$ ${layerNum}$$.\n\n ... $$\\phi$$ (in this case, $$tanh$$).`;
                        }
                }

                content = `$$${formula}$$\n\n${explanation}`;
            }



            renderInfoContent(infoElement, content);
        }


        function showReportingInfo(event) {
            const target = event.currentTarget;
            let content = '';

            function formatLossForLatex(lossValue) {
                if (lossValue === 'N/A') return 'N/A';
                const number = parseFloat(lossValue);
                if (isNaN(number)) return 'N/A';

                // Format to scientific notation with 5 decimal places
                let [coefficient, exponent] = number.toExponential(3).split('e');

                // Remove leading '+' from exponent if present
                exponent = parseInt(exponent);

                // Format for LaTeX
                return `${coefficient} \\times 10^{${exponent}}`;
            }

            if (target.id === 'epoch-display') {
                content = "An **epoch** is one complete pass through the entire training dataset. It represents a full cycle of training where the model has seen and learned from all available training examples once.";
            } else if (target.id === 'train-loss-display') {
                const trainLoss = formatLossForLatex(document.getElementById('train-loss-value').textContent);
                content = `**Training Loss**: The average loss (error) of the model on the training dataset.\n\nLower values indicate better performance on the training data.\n\nCurrent value: $$ ${trainLoss}$$`;
            } else if (target.id === 'val-loss-display') {
                const valLoss = formatLossForLatex(document.getElementById('val-loss-value').textContent);
                content = `**Validation Loss**: The average loss (error) of the model on the validation dataset.\n\nThis helps assess how well the model generalizes to unseen data.\n\nCurrent value: $$ ${valLoss}$$.`;
            }

            renderInfoContent(infoElement, content);
        }

        function showNetworkGradients() {


        }

        function clearInfo(event) {
            const defaultStr = ""; // TODO can edit this to be a general description about what we're doing

            if (!selectedElement) {
                document.getElementById('info').textContent = defaultStr;
            }
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Create figure labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function renderLatexLabelsDataPlot() {
            katex.render("\\mathbf{w} =", document.getElementById('w-label'), {
                throwOnError: false,
                displayMode: false,
                fontSize: '16px'
            });
            katex.render("\\mathbf{b} =", document.getElementById('b-label'), {
                throwOnError: false,
                displayMode: false,
                fontSize: '16px'
            });
        }


        function createLatexLabel(x, y, text, color, labelInfo) {
            const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            foreignObject.setAttribute('x', x - 75);
            foreignObject.setAttribute('y', y - 20);
            foreignObject.setAttribute('width', '150');
            foreignObject.setAttribute('height', '40');
            foreignObject.classList.add('latex-label');
            foreignObject.dataset.latex = text;
            foreignObject.dataset.info = labelInfo;

            const div = document.createElement('div');
            div.style.fontSize = LATEX_FONT_SIZE + 'px';
            div.style.color = color;
            div.style.display = 'flex';
            div.style.justifyContent = 'center';
            div.style.alignItems = 'center';
            div.style.height = '100%';

            katex.render(text, div, {
                throwOnError: false
            });

            foreignObject.appendChild(div);
            foreignObject.addEventListener('mouseover', showInfo);
            foreignObject.addEventListener('mouseout', clearInfo);
            foreignObject.addEventListener('click', showInfo);

            return foreignObject;
        }


        function addLayerLabels() {
            const layerGap = svgWidth / (layerDims.length + 2);

            // Input layer label
            svgNetwork.appendChild(createLatexLabel(layerGap, svgHeight - 20, '\\mathbf{x}', LATEX_COLOR, "x"));
            // Hidden layer labels
            for (let i = 1; i < layerDims.length - 1; i++) {
                svgNetwork.appendChild(createLatexLabel((i + 1) * layerGap, svgHeight - 20, `\\mathbf{x}:=\\phi(\\mathbf{W}_{${i}}\\mathbf{x})`, LATEX_COLOR, "fc" + i));
            }
            // Output layer label
            svgNetwork.appendChild(createLatexLabel(layerDims.length * layerGap, svgHeight - 20, `\\hat{\\mathbf{y}} := \\mathbf{W}_{${layerDims.length - 1}}\\mathbf{x}`, LATEX_COLOR, "y_hat"));
            // True values label
            svgNetwork.appendChild(createLatexLabel((layerDims.length + 1) * layerGap, svgHeight - 20, '\\mathbf{y}', LATEX_COLOR, "y"));
            // Weight labels
            for (let i = 1; i < layerDims.length; i++) {
                svgNetwork.appendChild(createLatexLabel(i * layerGap + layerGap / 2, 20, `\\mathbf{W}_{${i}}`, LATEX_COLOR, "W" + i));
            }
        }


        function addLossLabel() {
            const lastLayerX = (layerDims.length + 1) * (svgWidth / (layerDims.length + 2));
            const braceWidth = 15;
            svgNetwork.appendChild(createLatexLabel(lastLayerX + braceWidth * 1.5 + 80, svgHeight / 2, 'L(\\hat{\\mathbf{y}}, \\mathbf{y})', LATEX_COLOR_LOSS, "loss"));
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Rendering events and helpers
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function renderInfoContent(element, content) {
            element.innerHTML = '';
            let currentIndex = 0;

            while (currentIndex < content.length) {
                if (content.startsWith('$$', currentIndex)) {
                    // LaTeX content
                    const endIndex = content.indexOf('$$', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed LaTeX at position', currentIndex);
                        break;
                    }
                    const latexContent = content.slice(currentIndex + 2, endIndex);
                    const span = document.createElement('span');
                    katex.render(latexContent, span, {
                        throwOnError: false,
                        displayMode: false
                    });
                    element.appendChild(span);
                    currentIndex = endIndex + 2;
                } else if (content.startsWith('**', currentIndex)) {
                    // Bold content
                    const endIndex = content.indexOf('**', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed bold at position', currentIndex);
                        break;
                    }
                    const boldContent = content.slice(currentIndex + 2, endIndex);
                    const strong = document.createElement('strong');
                    strong.textContent = boldContent;
                    element.appendChild(strong);
                    currentIndex = endIndex + 2;
                } else {
                    // Plain text
                    const nextSpecialChar = Math.min(
                        content.indexOf('$$', currentIndex) === -1 ? Infinity : content.indexOf('$$', currentIndex),
                        content.indexOf('**', currentIndex) === -1 ? Infinity : content.indexOf('**', currentIndex)
                    );
                    const textContent = content.slice(currentIndex, nextSpecialChar === Infinity ? undefined : nextSpecialChar);
                    const lines = textContent.split('\n');
                    lines.forEach((line, index) => {
                        element.appendChild(document.createTextNode(line));
                        if (index < lines.length - 1) {
                            element.appendChild(document.createElement('br'));
                        }
                    });
                    currentIndex = nextSpecialChar === Infinity ? content.length : nextSpecialChar;
                }
            }
        }


        function handleNodeHover(event) {

        }


        function resetConnectionHighlights() {
            // used for clearing node hover and update hover events
            // if (selectedElement) return; // Don't reset if there's a selected element
            const highlightedConnections = document.querySelectorAll('.connection.highlighted');
            highlightedConnections.forEach(conn => {
                conn.classList.remove('highlighted', 'positive', 'negative');
                conn.setAttribute('stroke-width', '1');
                conn.style.filter = '';
            });
        }


        function resetConnectionAppearance(event) {
            const target = event.target;
            if (target.classList.contains('connection')) {
                target.style.filter = '';
                target.classList.remove('highlighted', 'positive', 'negative');
            }
        }


        function updateConnectionOpacity() {
            const connections = document.querySelectorAll('.connection');
            connections.forEach(connection => {
                const strength = Math.abs(parseFloat(connection.dataset.strength));
                // const maxStrength = parseFloat(connection.dataset.maxStrength);
                const opacity = strength / maxStrength;
                connection.setAttribute('stroke-opacity', opacity);
            });
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Animations
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function animateForwardPass() {

        }

        function animateBackwardPass() {

        }



        function resetTrainingDisplay() {
            document.getElementById('epoch-display').textContent = `Epoch: 0`;
            document.getElementById('train-loss-value').textContent = 'N/A';
            document.getElementById('val-loss-value').textContent = 'N/A';
        }


        function updateTrainingDisplay(epochVal, trainLoss, valLoss) {
            document.getElementById('epoch-display').textContent = `Epoch: ${epochVal}`;
            if (trainLoss !== null) {
                document.getElementById('train-loss-value').textContent = trainLoss.toFixed(20);
            }
            if (valLoss !== null) {
                document.getElementById('val-loss-value').textContent = valLoss.toFixed(20);
            }
        }


        function logMessage(message) {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML += `<p>${message}</p>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Random Number Generation
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        class RNG {
            constructor(seed) {
                this.state = BigInt(seed);
            }

            random_u32() {
                // xorshift rng: https://en.wikipedia.org/wiki/Xorshift#xorshift.2A
                this.state = BigInt.asUintN(64, this.state);
                this.state ^= (this.state >> 12n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state << 25n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state >> 27n) & 0xFFFFFFFFFFFFFFFFn;

                return Number((this.state * 0x2545F4914F6CDD1Dn >> 32n) & 0xFFFFFFFFn);
            }

            random() {
                // random Number in [0, 1)
                return (this.random_u32() >>> 8) / 16777216.0;
            }

            uniform(a = 0.0, b = 1.0) {
                // random Number in [a, b)
                return a + (b - a) * this.random();
            }
        }

        function gen_data_linear_regression(random, n = 100) {
            let pts = [];
            for (let i = 0; i < n; i++) {
                let x = random.uniform(-5.0, 5.0);
                let noise = random.uniform(-noiseScale, noiseScale);
                let y = w_true * x + b_true + noise
                pts.push([x, y]);
            }
            // create train/val/test splits of the data (80%, 10%, 10%)
            let tr = pts.slice(0, Math.floor(0.8 * n));
            let val = pts.slice(Math.floor(0.8 * n), Math.floor(0.9 * n));
            let te = pts.slice(Math.floor(0.9 * n));
            return [tr, val, te];
        }

        function gen_data(random, n = 100) {
            let pts = [];
            for (let i = 0; i < n; i++) {
                let x = random.uniform(-2.0, 2.0);
                let y = random.uniform(-2.0, 2.0);
                // concentric circles
                // label = 0 if x**2 + y**2 < 1 else 1 if x**2 + y**2 < 2 else 2
                // very simple dataset
                let label = x < 0 ? 0 : y < 0 ? 1 : 2;
                pts.push([[x, y], label]);
            }
            // create train/val/test splits of the data (80%, 10%, 10%)
            let tr = pts.slice(0, Math.floor(0.8 * n));
            let val = pts.slice(Math.floor(0.8 * n), Math.floor(0.9 * n));
            let te = pts.slice(Math.floor(0.9 * n));
            return [tr, val, te];
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Micrograd MLP (visual update)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function zeroGradViz() {
            const connections = document.querySelectorAll('.connection');
            connections.forEach(connection => {
                if (connection.dataset.gradient) {
                    connection.dataset.gradient = '0';
                }
                connection.style.filter = ''; // Reset any gradient-based styling
            });
        }



        function updateFwdBackUpButton(button, stage) {
            switch (stage) {
                case 0:
                    button.textContent = '→';
                    break;
                case 1:
                    button.textContent = '←';
                    break;
                case 2:
                    button.textContent = '↑';
                    break;
            }
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Micrograd MLP
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        class Value {
            // stores a single scalar value and its gradient
            constructor(data, _children = [], _op = '') {
                this.data = data;
                this.grad = 0;
                this._backward = () => { };
                this._prev = new Set(_children);
                this._op = _op;
            }

            add(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data + other.data, [this, other], '+');
                out._backward = () => {
                    this.grad += out.grad;
                    other.grad += out.grad;
                };

                return out;
            }

            mul(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data * other.data, [this, other], '*');
                out._backward = () => {
                    this.grad += other.data * out.grad;
                    other.grad += this.data * out.grad;
                };

                return out;
            }

            pow(other) {
                if (typeof other !== 'number') throw new Error("only supporting number powers for now");
                const out = new Value(Math.pow(this.data, other), [this], `**${other}`);

                out._backward = () => {
                    this.grad += other * Math.pow(this.data, other - 1) * out.grad;
                };

                return out;
            }

            relu() {
                const out = new Value(this.data < 0 ? 0 : this.data, [this], 'ReLU');
                out._backward = () => {
                    this.grad += (out.data > 0) * out.grad;
                };

                return out;
            }

            tanh() {
                const x = Math.tanh(this.data);
                const out = new Value(x, [this], 'tanh');
                out._backward = () => {
                    this.grad += (1 - x * x) * out.grad;
                };

                return out;
            }

            exp() {
                const x = Math.exp(this.data);
                const out = new Value(x, [this], 'exp');
                out._backward = () => {
                    this.grad += x * out.grad;
                };

                return out;
            }

            log() {
                const out = new Value(Math.log(this.data), [this], 'log');
                out._backward = () => {
                    this.grad += (1 / this.data) * out.grad;
                };

                return out;
            }

            backward() {
                const topo = [];
                const visited = new Set();

                function buildTopo(v) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        for (const child of v._prev) {
                            buildTopo(child);
                        }
                        topo.push(v);
                    }
                }

                buildTopo(this);

                this.grad = 1;
                for (const v of topo.reverse()) {
                    v._backward();
                }
            }

            neg() { return this.mul(-1); }
            sub(other) { return this.add(other instanceof Value ? other.neg() : new Value(-other)); }
            div(other) { return this.mul(other instanceof Value ? other.pow(-1) : new Value(Math.pow(other, -1))); }

            toString() {
                return `Value(data=${this.data}, grad=${this.grad})`;
            }
        }


        class Module {
            zeroGrad() {
                for (const p of this.parameters()) {
                    p.grad = 0;
                }
                zeroGradViz(); // update connection gradients on SVG
            }

            parameters() {
                return [];
            }
        }

        class Neuron extends Module {
            constructor(nin, kwargs) {
                super();
                this.w = Array(nin).fill().map(() => new Value(random.uniform(-1, 1) * Math.pow(nin, -0.5)));
                this.b = new Value(0);

                this.nonlin = kwargs.nonlin !== undefined ? kwargs.nonlin : true;
            }

            call(x) {
                const act = this.w.reduce((sum, wi, i) => sum.add(wi.mul(x[i])), this.b);
                return this.nonlin ? act.tanh() : act;
            }

            parameters() {
                return [...this.w, this.b];
            }

            toString() {
                return `${this.nonlin ? 'TanH' : 'Linear'}Neuron(${this.w.length})`;
            }
        }

        class Layer extends Module {
            constructor(nin, nout, kwargs = {}) {
                super();
                this.neurons = Array(nout).fill().map(() => new Neuron(nin, kwargs));
            }

            call(x) {
                const out = this.neurons.map(n => n.call(x));
                return out;
            }

            parameters() {
                return this.neurons.flatMap(n => n.parameters());
            }

            toString() {
                return `Layer of [${this.neurons.join(', ')}]`;
            }
        }

        class MLP extends Module {
            constructor(nin, nouts) {
                super();
                const sz = [nin, ...nouts];
                this.layers = sz.slice(0, -1).map((s, i) => new Layer(s, sz[i + 1], { nonlin: i !== nouts.length - 1 }));

            }

            call(x) {
                for (const layer of this.layers) {
                    x = layer.call(x);
                }
                return x
            }

            parameters() {
                return this.layers.flatMap(l => l.parameters());
            }

            toString() {
                return `MLP of [${this.layers.join(', ')}]`;
            }

            shockWeights() {
                for (const layer of this.layers) {
                    for (const neuron of layer.neurons) {
                        for (const w of neuron.w) {
                            const noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                            w.data += noise;
                        }
                        const bias_noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                        neuron.b.data += bias_noise;
                    }
                }
            }
        }

        function crossEntropy(logits, target) {
            // subtract the max for numerical stability (avoids overflow)
            const maxVal = Math.max(...logits.map(v => v.data));
            const shiftedLogits = logits.map(v => v.sub(maxVal));
            // 1) evaluate elementwise e^x
            const ex = shiftedLogits.map(x => x.exp());
            // 2) compute the sum of the above
            const denom = ex.reduce((sum, x) => sum.add(x));
            // 3) normalize by the sum to get probabilities
            const probs = ex.map(x => x.div(denom));
            // 4) log the probabilities at target
            const logp = probs[target].log();
            // 5) the negative log likelihood loss (invert so we get a loss - lower is better)
            const nll = logp.neg();
            return nll;
        }

        // evaluation utility to compute the loss on a given split of the dataset
        function evalSplit(model, split) {
            // evaluate the loss of a split
            let loss = new Value(0);
            // track for plotting
            logitsVal = [];
            predsVal = [];
            for (const [x, y] of split) {
                const logits = model.call([new Value(x[0]), new Value(x[1])]);
                logitsVal.push(logits);
                predsVal.push(argmax(logits.map(v => v.data)));
                loss = loss.add(crossEntropy(logits, y));
            }
            loss = loss.mul(1.0 / split.length); // normalize the loss
            return loss.data;
        }

        function trainForward() {
            // forward pass
            if (epoch % 10 === 0) {
                const val_loss = evalSplit(mlp, val_split);
                updateTrainingDisplay(epoch, null, val_loss);
            }

            loss = new Value(0);
            // track for plotting
            logitsTrain = [];
            predsTrain = [];
            for (const [x, y] of train_split) {
                const logits = mlp.call([new Value(x[0]), new Value(x[1])]);
                logitsTrain.push(logits);
                predsTrain.push(argmax(logits.map(v => v.data)));
                loss = loss.add(crossEntropy(logits, y));
            }
            loss = loss.mul(1.0 / train_split.length);
            updateTrainingDisplay(epoch, loss.data, null);

            updateDataPlot();
        }

        function trainBackward() {
            // backward pass (deposit the gradients)
            loss.backward();
            updatedGradViz();
        }

        function trainUpdate() {
            // update with AdamW
            for (const p of mlp.parameters()) {
                p.m = beta1 * p.m + (1 - beta1) * p.grad;
                p.v = beta2 * p.v + (1 - beta2) * Math.pow(p.grad, 2);
                const m_hat = p.m / (1 - Math.pow(beta1, epoch + 1));
                const v_hat = p.v / (1 - Math.pow(beta2, epoch + 1));
                p.data -= learning_rate * (m_hat / (Math.sqrt(v_hat) + eps) + weight_decay * p.data);
            }
            updatedStrengthViz();
            mlp.zeroGrad();
            updateTrainingDisplay(epoch, loss.data, null);

            epoch++;
        }

        function trainModelStep(stage, fullStep = false) {
            if (!mlp) {
                console.error("MLP not initialized");
                return;
            }

            if (fullStep) {
                resetCurrentTrainingStage();
                trainForward();
                trainBackward();
                trainUpdate();
            } else {
                // only animimate forward and backward passes on partial steps
                switch (stage) {
                    case 0: // Forward pass
                        trainForward();
                        animateForwardPass();
                        break;

                    case 1: // Backward pass
                        trainBackward();
                        animateBackwardPass();
                        break;
                    case 2: // Update
                        trainUpdate();
                        break;
                }
                currentTrainingStage = (stage + 1) % 3;
                updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
            }
        }

        function trainModel(state) {
            function trainingLoop() {
                if (!isRunningOptimization) return;

                trainModelStep(state, true);

                if (currentTrainingStage === 0) {
                    // We've completed a full cycle, request the next frame
                    requestAnimationFrame(trainingLoop);
                } else {
                    // We're in the middle of a cycle, continue immediately
                    trainingLoop();
                }
            }
            trainingLoop();
        }

        function resetCurrentTrainingStage() {
            // in case we are partway through a cycle, reset stage and grad
            currentTrainingStage = 0;
            mlp.zeroGrad();
            updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
        }

        function argmax(array) {
            if (array.length === 0) {
                return -1; // Return -1 for empty array
            }
            const max = Math.max(...array);
            return array.indexOf(max);
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Add event listeners and draw
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        const random = new RNG(42);

        svgNetwork.addEventListener('click', function (event) {
            showInfo(event);
        });

        function addEventListeners(element) {
            element.addEventListener('mouseover', showInfo);
            element.addEventListener('mouseout', clearInfo);
            element.addEventListener('click', showInfo);
        }

        function setInitialValues() {
            document.getElementById('w-input').value = w_true;
            document.getElementById('b-input').value = b_true;
            document.getElementById('noise-input').value = noiseScale;
        }


        document.querySelectorAll('.node, .connection, .layer, .latex-label').forEach(addEventListeners);

        window.onload = function () {
            initializeD3Plot();
            renderLatexLabelsDataPlot();
            setInitialValues();
            resetData();
        };

    </script>
</body>

</html>