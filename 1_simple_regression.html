<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Regression</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        #reporting-container {
            font-size: 16px;
            line-height: 1.5;
            font-family: 'Courier New', Courier, monospace;
            padding: 20px;
        }

        .loss-display {
            display: flex;
        }

        .loss-label {
            width: 250px;
            /* Adjust this value as needed */
        }

        #main-container {
            display: flex;
            width: 100%;
            height: 700px;
        }

        #svg-container {
            flex: 0 0 1200px;
            z-index: 10;
            /* overflow: auto; */
        }

        #right-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #info-container {
            /* flex: 1; */
            min-height: 350px;
            padding: 15px;
            overflow-y: auto;
        }

        .container {
            display: flex;
            justify-content: center;
        }

        #controls {
            padding: 0 20px;
            display: flex;
            justify-content: center;
        }

        .data-params-span {
            margin-top: 5px;
            justify-content: center;
            font-size: 16px;
        }

        #bottom-right-container {
            flex: 1;
            padding: 15px 20px;
            overflow-y: visible;
        }

        #info {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            line-height: 1.5;

            height: 250px;
            border-radius: 15px;
            overflow-y: auto;

        }

        #info .katex {
            font-size: 1.2em;
        }

        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        /* MLP CSS*/
        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        #network {
            border: 1px solid #ccc;
        }

        .data-params-input {
            width: 35px;
            font-size: 16px;
            font-weight: 500;
            border: 0;
            background-color: rgb(240, 240, 249);
            margin: 0 4px;
        }

        .data-params-input:hover {
            outline: 1px solid navy;
        }

        .layer:hover rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.1;
        }

        .latex-label:hover {
            filter: brightness(0.5);
        }

        .latex-label.selected {
            filter: brightness(0.5);
        }

        .layer.selected>rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.3;
        }

        /* Connections */
        .connection:hover {
            stroke-width: 4;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));
        }

        .connection.positive {
            stroke: rgb(100, 100, 255);
        }

        .connection.negative {
            stroke: rgb(255, 100, 100);
        }

        .connection.selected {
            stroke-width: 3;
            stroke-opacity: 1;
        }

        /* Nodes */
        .node {
            cursor: pointer;
        }

        .node:hover {
            fill: #ffb650;
        }

        .node.selected {
            fill: #ffb650;
        }

        /* MLP actions */
        #button-group-container {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        #button-group {
            display: flex;
            align-items: center;
        }

        #button-group button {
            margin: 0 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #btn-regen-data {
            margin: 0 10px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            /* border: 1px solid rgba(0, 0, 128, 0.4); */
            border: 0;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #button-group .large-button {
            font-size: 24px;
            width: 50px;
            height: 50px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
        }


        #button-group .small-button {
            font-size: 18px;
            padding: 8px 16px;
            width: 50px;
            height: 40px;
        }

        #button-group button:hover,
        #btn-regen-data:hover {
            background-color: #e0f1f2;
        }

        #button-group button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #eee;
        }

        /* Data plot */
        #data-visualization {
            margin-top: 30px;
        }

        #data-plot {
            border: 1px solid #ccc;
        }

        .data-point {
            stroke-width: 2;
            fill: none;
        }

        .data-point.hit {
            fill-opacity: 0.3;
        }

        /* .data-point.train {} */

        .data-point.val {
            stroke: #999;
            stroke-width: 2;
        }

        .data-point.miss {
            fill-opacity: 1;
        }

        .label-missing {
            fill: gray;
            fill-opacity: 1;
        }

        .regression {
            fill: navy;
        }

        .label-0 {
            fill: navy;
        }

        .label-1 {
            fill: gold;
        }

        .label-2 {
            fill: red;
        }

        .prediction-line {
            pointer-events: none;
        }
    </style>
    <!-- for LaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <!-- for anim -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <!-- for plotting data -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        HTML
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <div id="main-container">
        <div id="svg-container">
            <svg id="network" width="1200" height="700"></svg>
        </div>
        <div id="right-container">
            <div id="info-container">
                <div id="info"></div>
                <div id="button-group-container">
                    <div id="button-group">
                        <button id="btn-reset-mlp" class="small-button">↺</button>
                        <button id="btn-shock-weights" class="small-button">ϟ</button>
                        <button id="btn-play-pause" class="large-button">
                            <span id="btn-play-pause-content">▶</span>
                        </button>
                        <button id="btn-step" class="small-button">▶|</button>
                        <button id="btn-fwd-backprop-update" class="small-button">→</button>
                    </div>
                </div>
            </div>
            <div id="bottom-right-container">
                <div id="controls">
                    <span id="w-label" class="data-params-span">w =</span><input type="text" id="w-input" class="data-params-input">
                    <span id="b-label" class="data-params-span">b =</span><input type="text" id="b-input" class="data-params-input">
                    <span class="data-params-span">noise =</span><input type="text" id="noise-input" class="data-params-input">
                    <button id="btn-regen-data" onclick="resetData()">Regenerate data</button>
                </div>
                <div class="container">
                    <div id="data-visualization">
                        <!-- <svg id="data-plot" width="380" height="380"></svg> -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="reporting-container">
        <div id="epoch-display">Epoch: N/A</div>
        <div id="train-loss-display" class="loss-display">
            <span class="loss-label">Training Loss:</span>
            <span id="train-loss-value">N/A</span>
        </div>
        <div id="val-loss-display" class="loss-display">
            <span class="loss-label">Validation Loss:</span>
            <span id="val-loss-value">N/A</span>
        </div>
        <div id="log-container"></div>
    </div>



    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Javascript
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <script>
        // globals
        let mlp;
        const layerDims = [1,1];
        let train_split, val_split, test_split;
        let predsTrain, predsVal;

        let isRunningOptimization = false;
        let epoch = 0;

        let currentTrainingStage = 0; // 0: forward, 1: backward, 2: update
        let maxStrength = 0.001;
        let maxGradient = 0.001;

        // Linear Regression
        let w_pred = 1;
        let b_pred = 0;
        let w_true = -2;
        let b_true = 3;
        let noiseScale = 5;

        const x_min = -4
        const x_max = 4

        // AdamW
        let learning_rate = 1e-1;
        let beta1 = 0.9;
        let beta2 = 0.95;
        let weight_decay = 1e-4;
        const eps = 1e-8;

        const shockNoiseScale = 0.3; // Adjust this value to control the magnitude of the shock

        const btnPlayPause = document.getElementById('btn-play-pause');
        const btnStep = document.getElementById('btn-step');
        const btnResetMLP = document.getElementById('btn-reset-mlp');
        const btnFwdBackUp = document.getElementById('btn-fwd-backprop-update');

        const infoElement = document.getElementById('info');

        let selectedElement = null;
        const svgNetwork = document.getElementById('network');

        let svgWidth = 1200;
        let svgHeight = 700;

        const valInterval = 10; // interval for calculating validation loss

        const LATEX_FONT_SIZE = 16;
        const LATEX_COLOR = '#999';
        const LATEX_COLOR_LOSS = '#666';
        const layerColors = {
            x: {
                shape: "#ccc",
                overlay: "rgba(204, 204, 204, 0.1)"
            },
            fc: {
                // keep layer display minimaly white for now
                shape: '#FFFFFF',
                overlay: "rgba(255, 255, 255, 0.2)"
            },
            y: {
                shape: "#ccc",
                overlay: "rgba(204, 204, 204, 0.1)"
            },
            bias: {
                shape: "#999",
            }
        };

        // Global variables for D3.js plot
        let svg, x, y, xAxis, yAxis, scatter;
        let currentTransform = d3.zoomIdentity;


        function getLayerColor(layerIndex) {
            if (layerIndex === 0) return layerColors.x;
            if (layerIndex === layerDims.length) return layerColors.y;
            return layerColors.fc;
        }


        function resetAdamMLP() {
            for (const p of mlp.parameters()) {
                p.m = 0.0;
                p.v = 0.0;
            }
        }

        function resetData() {
            w_true = parseFloat(document.getElementById('w-input').value);
            b_true = parseFloat(document.getElementById('b-input').value);
            noiseScale = parseFloat(document.getElementById('noise-input').value);


            [train_split, val_split, test_split] = gen_data_linear_regression(random, 100);
            epoch = 0;
            predsTrain = [];
            predsVal = [];
            updateDataPlot();
        }

        function resetMLP() {
            mlp = new MLP(1, [1]);
            resetAdamMLP();

            currentTrainingStage = 0;
            epoch = 0;
            resetTrainingDisplay();
            updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
            predsTrain = [];
            predsVal = [];
            updateDataPlot();

            // Clear the existing SVG and draw the new network
            drawNetwork();
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw the MLP
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function setMaxes() {
            if (!mlp) {
                return
            }
            // Get maxStrength and maxGradient over the mlp params
            [maxStrength, maxGradient] = mlp.parameters().reduce((max, v) => [
                Math.max(max[0], Math.abs(v.data)),
                Math.max(max[1], Math.abs(v.grad))
            ], [-Infinity, -Infinity]);
        }

        function drawNetwork() {
            svg.innerHTML = '';

            const layerGap = svgWidth / (layerDims.length + 2);
            setMaxes(); // get max strength and gradient of network for drawing

            // draw layer rectangles, nodes, and connections for each layer
            const layerGroupWidth = 30;
            for (let layerIndex = 0; layerIndex < layerDims.length; layerIndex++) {
                const nodeCountNoBias = layerDims[layerIndex]

                const svgX = (layerIndex + 1) * layerGap;
                const layerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                layerGroup.classList.add('layer');
                layerGroup.dataset.layer = layerIndex;

                const layerRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                layerRect.setAttribute('x', svgX - layerGroupWidth / 2);
                layerRect.setAttribute('y', 0);
                layerRect.setAttribute('width', layerGroupWidth);
                layerRect.setAttribute('height', svgHeight);
                const layerColor = getLayerColor(layerIndex);
                layerRect.setAttribute('fill', layerColor.overlay);

                layerGroup.appendChild(layerRect);

                layerGroup.addEventListener('mouseover', showInfo);
                layerGroup.addEventListener('mouseout', clearInfo);
                // layerGroup.addEventListener('click', showInfo);

                const totalNodes = layerIndex < layerDims.length - 1 ? nodeCountNoBias + 1 : nodeCountNoBias;

                for (let i = 0; i < nodeCountNoBias; i++) {
                    const svgY = (i + 1) * (svgHeight / (totalNodes + 1));
                    drawNode(svgX, svgY, layerIndex, i, layerGroup);
                }

                // Add bias node for all layers except the last one
                if (layerIndex < layerDims.length - 1) {
                    const biasY = (nodeCountNoBias + 1) * (svgHeight / (totalNodes + 1));
                    drawBiasNode(svgX, biasY, layerIndex, layerGroup);
                }

                svgNetwork.appendChild(layerGroup);

                // Draw connections
                if (layerIndex < layerDims.length - 1) {
                    drawConnections(layerIndex, svgX, layerGap);
                }
            }

            // Draw the additional "y" layer
            const yLayerX = (layerDims.length + 1) * layerGap;
            const yLayerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            yLayerGroup.classList.add('layer');
            yLayerGroup.dataset.layer = layerDims.length;

            const yLayerRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            yLayerRect.setAttribute('x', yLayerX - layerGroupWidth / 2);
            yLayerRect.setAttribute('y', 0);
            yLayerRect.setAttribute('width', layerGroupWidth);
            yLayerRect.setAttribute('height', svgHeight);
            yLayerRect.setAttribute('fill', layerColors.y.overlay);

            yLayerGroup.appendChild(yLayerRect);

            yLayerGroup.addEventListener('mouseover', showInfo);
            yLayerGroup.addEventListener('mouseout', clearInfo);
            // yLayerGroup.addEventListener('click', showInfo);

            const lastLayerNodeCount = layerDims[layerDims.length - 1];
            for (let i = 0; i < lastLayerNodeCount; i++) {
                const svgY = (i + 1) * (svgHeight / (lastLayerNodeCount + 1));
                drawNode(yLayerX, svgY, layerDims.length, i, yLayerGroup);
            }

            svgNetwork.appendChild(yLayerGroup);

            // Draw connections between y_hat and y
            drawYConnections(layerDims.length - 1, (layerDims.length) * layerGap, layerGap);

            // Draw the curly brace and "loss" text
            const lastLayerX = (layerDims.length + 1) * layerGap;
            const braceWidth = layerGroupWidth / 2;
            const topNodeY = (1) * (svgHeight / (lastLayerNodeCount + 1));
            const bottomNodeY = (lastLayerNodeCount) * (svgHeight / (lastLayerNodeCount + 1));
            const braceHeight = bottomNodeY - topNodeY;
            const braceX = lastLayerX + layerGroupWidth;
            const braceY = topNodeY;

            const brace = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            brace.setAttribute('d', `M ${braceX} ${braceY}
                         C ${braceX} ${braceY + braceHeight * 0.05}, ${braceX + braceWidth * 0.6} ${braceY + braceHeight * 0.1}, ${braceX + braceWidth * 0.8} ${braceY + braceHeight * 0.2}
                         C ${braceX + braceWidth} ${braceY + braceHeight * 0.3}, ${braceX + braceWidth} ${braceY + braceHeight * 0.4}, ${braceX + braceWidth} ${braceY + braceHeight * 0.45}
                         L ${braceX + braceWidth * 1.5} ${braceY + braceHeight * 0.5}
                         L ${braceX + braceWidth} ${braceY + braceHeight * 0.55}
                         C ${braceX + braceWidth} ${braceY + braceHeight * 0.6}, ${braceX + braceWidth} ${braceY + braceHeight * 0.7}, ${braceX + braceWidth * 0.8} ${braceY + braceHeight * 0.8}
                         C ${braceX + braceWidth * 0.6} ${braceY + braceHeight * 0.9}, ${braceX} ${braceY + braceHeight * 0.95}, ${braceX} ${braceY + braceHeight}`);
            brace.setAttribute('fill', 'none');
            brace.setAttribute('stroke', '#ccc');
            brace.setAttribute('stroke-width', '2');
            svgNetwork.appendChild(brace);

            addLayerLabels();
            addLossLabel();
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw nodes
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawNode(x, y, layerIndex, nodeIndex, parent, isBiasNode = false) {
            const r = 10;
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            const shapeColor = isBiasNode ? layerColors.bias.shape : getLayerColor(layerIndex).shape
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', isBiasNode ? r / 2 : r);
            circle.setAttribute('fill', shapeColor);
            circle.setAttribute('stroke', 'gray');
            circle.setAttribute('stroke-width', '1');
            circle.classList.add('node');
            circle.dataset.layer = layerIndex;
            circle.dataset.node = nodeIndex;
            parent.appendChild(circle);

            circle.addEventListener('mouseover', showInfo);
            circle.addEventListener('mouseout', clearInfo);
            // circle.addEventListener('click', showInfo);
            circle.addEventListener('mouseenter', handleNodeHover);
            circle.addEventListener('mouseleave', resetConnectionHighlights);
        }

        function drawBiasNode(x, y, layerIndex, parent) {
            drawNode(x, y, layerIndex, layerDims[layerIndex], parent, true);
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw connections
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawConnections(layerIndex, layerXCoord, layerGap) {
            const currentLayer = mlp.layers[layerIndex];
            const currentLayerSize = currentLayer.neurons.length;
            const maxOpacity = 1;

            for (let i = 0; i < currentLayerSize; i++) {
                const neuron = currentLayer.neurons[i];
                let toY = (i + 1) * (svgHeight / (currentLayerSize + 2));
                if (layerIndex == layerDims.length - 2) {
                    // y_hat, no bias
                    toY = (i + 1) * (svgHeight / (currentLayerSize + 1));
                }
                // these weights project backward, meaning they describe how these neurons
                // connect to the previous layers nodes
                const neuronWeights = neuron.parameters()
                const prevLayerSize = neuronWeights.length

                for (let j = 0; j < prevLayerSize; j++) {
                    const fromY = (j + 1) * (svgHeight / (prevLayerSize + 1));
                    const weight = neuronWeights[j];

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', layerXCoord);
                    line.setAttribute('y1', fromY);
                    line.setAttribute('x2', layerXCoord + layerGap);
                    line.setAttribute('y2', toY);
                    line.setAttribute('stroke', '#999');
                    line.setAttribute('stroke-width', '1');

                    const strength = weight.data;
                    const opacity = Math.min(Math.abs(strength) / maxStrength, maxOpacity);
                    line.setAttribute('stroke-opacity', opacity);

                    line.classList.add('connection');
                    line.dataset.from = `${layerIndex},${j}`;
                    line.dataset.to = `${layerIndex + 1},${i}`;
                    line.dataset.strength = strength.toFixed(4);
                    line.dataset.gradient = weight.grad.toFixed(4);

                    svgNetwork.appendChild(line);

                    line.addEventListener('mouseover', showInfo);
                    line.addEventListener('mouseout', (event) => {
                        clearInfo(event);
                        resetConnectionAppearance(event);
                    });
                }
            }
        }


        function drawYConnections(layerIndex, x, layerGap) {
            const currentLayer = layerDims[layerIndex];

            for (let i = 0; i < currentLayer; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', (i + 1) * (svgHeight / (currentLayer + 1)));
                line.setAttribute('x2', x + layerGap);
                line.setAttribute('y2', (i + 1) * (svgHeight / (currentLayer + 1)));
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('stroke-dasharray', '5,5');

                line.classList.add('connection');
                line.dataset.from = `${layerIndex},${i}`;
                line.dataset.to = `${layerIndex + 1},${i}`;
                svgNetwork.appendChild(line);

                line.addEventListener('mouseover', showInfo);
                line.addEventListener('mouseout', clearInfo);
                line.addEventListener('click', showInfo);
            }
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw data points (d3.js)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function initializeD3Plot() {
            const margin = { top: 10, right: 30, bottom: 30, left: 60 };
            const width = 450 - margin.left - margin.right;
            const height = 380 - margin.top - margin.bottom;

            // Append the SVG object to the data-visualization div
            svg = d3.select("#data-visualization")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add X axis
            x = d3.scaleLinear()
                .domain([-15, 15])
                .range([0, width]);
            xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y axis
            y = d3.scaleLinear()
                .domain([-15, 15])
                .range([height, 0]);
            yAxis = svg.append("g")
                .call(d3.axisLeft(y));

            // Add grid line at x = 0
            svg.append("line")
                .attr("class", "grid-line vertical")
                .attr("x1", x(0))
                .attr("y1", 0)
                .attr("x2", x(0))
                .attr("y2", height)
                .attr("stroke", "#ddd")
                .attr("stroke-dasharray", "4");

            // Add grid line at y = 0
            svg.append("line")
                .attr("class", "grid-line horizontal")
                .attr("x1", 0)
                .attr("y1", y(0))
                .attr("x2", width)
                .attr("y2", y(0))
                .attr("stroke", "#ddd")
                .attr("stroke-dasharray", "4");


            // Add a clipPath to ensure that elements are only visible within a specific area
            svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            scatter = svg.append('g')
                .attr("clip-path", "url(#clip)");

            // Add zoom capabilities
            const zoom = d3.zoom()
                .scaleExtent([0.8, 10])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all") // IMPORTANT allow panning and zoom
                .style("cursor", "move")
                .lower() // IMPORTANT Move this rect to the back to capture on hover effects for data points
                .call(zoom);
        }

        function updateChart(event) {
            currentTransform = event.transform;
            // Recover new scale
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            // Update axes
            xAxis.call(d3.axisBottom(newX));
            yAxis.call(d3.axisLeft(newY));

            // Update vertical grid line (x = 0)
            svg.select(".grid-line.vertical")
                .attr("x1", newX(0))
                .attr("x2", newX(0));

            // Update horizontal grid line (y = 0)
            svg.select(".grid-line.horizontal")
                .attr("y1", newY(0))
                .attr("y2", newY(0));


            // Update circle positions
            scatter.selectAll("circle")
                .attr('cx', d => newX(d[0]))
                .attr('cy', d => newY(d[1]));

            // Update true line
            const lineData = [
                { x: newX.domain()[0], y: w_true * newX.domain()[0] + b_true },
                { x: newX.domain()[1], y: w_true * newX.domain()[1] + b_true }
            ];

            const line = d3.line()
                .x(d => newX(d.x))
                .y(d => newY(d.y));

            scatter.select(".true-line")
                .datum(lineData)
                .attr("d", line);

            // Update predicted line
            drawPredictedLine(newX, newY);


        }

        function updateDataPlot() {
            // currentTransform = d3.zoomIdentity;
            // Clear existing content
            scatter.selectAll("*").remove();

            // Plot training data
            plotDataPointsRegression(train_split, predsTrain, true);

            // Plot validation data
            plotDataPointsRegression(val_split, predsVal, false);

            // Draw the true line
            drawTrueLine();

            // Draw the predicted line
            drawPredictedLine(x, y);

            // Apply the current transform to maintain zoom and pan state
            // svg.select("rect").call(zoom.transform, currentTransform);
        }

       
        function drawTrueLine() {
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            const lineData = [
                { x: newX.domain()[0], y: w_true * newX.domain()[0] + b_true },
                { x: newX.domain()[1], y: w_true * newX.domain()[1] + b_true }
            ];

            const line = d3.line()
                .x(d => newX(d.x))
                .y(d => newY(d.y));

            scatter.append("path")
                .datum(lineData)
                .attr("class", "true-line")
                .attr("fill", "none")
                .attr("stroke", "navy")
                .attr("stroke-width", 3)
                .attr("d", line)
                .on("mouseover", showYTrueInfo)
                .on("mouseout", function () {
                    clearInfo();
                    scatter.selectAll(".dotted-line").remove();
                });
        }


        function drawPredictedLine() {
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            const lineData = [
                { x: newX.domain()[0], y: w_pred * newX.domain()[0] + b_pred },
                { x: newX.domain()[1], y: w_pred * newX.domain()[1] + b_pred }
            ];

            const line = d3.line()
                .x(d => newX(d.x))
                .y(d => newY(d.y));

            scatter.selectAll(".predicted-line").remove();
            scatter.append("path")
                .datum(lineData)
                .attr("class", "predicted-line")
                .attr("fill", "none")
                .attr("stroke", "#bbb")
                .attr("stroke-width", 3)
                .attr("d", line)
                .on("mouseover", showYPredInfo)
                .on("mouseout", clearInfo);
        }

        function drawLineToPrediction(xValue, yValue, yPred) {
            // Remove any existing line
            scatter.selectAll(".prediction-line").remove();

            // Use the current transform to scale the coordinates
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            // Draw the line
            scatter.append("line")
                .attr("class", "prediction-line")
                .attr("x1", newX(xValue))
                .attr("y1", newY(yValue))
                .attr("x2", newX(xValue))
                .attr("y2", newY(yPred))
                .attr("stroke", "red")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");
        }



        


        // function plotDataPointsRegression(dataPoints, predictions, isTrainingSet, r = 5) {
        //     const className = isTrainingSet ? "train-point" : "val-point";

        //     scatter.selectAll(`.${className}`)
        //         .data(dataPoints)
        //         .join("circle")
        //         .attr("class", `data-point regression ${isTrainingSet ? 'train' : 'val'}`)
        //         .attr("cx", d => x(d[0]))
        //         .attr("cy", d => y(d[1]))
        //         .attr("r", r)
        //         .on("mouseover", (event, d) => {
        //             showDataPointInfo(event, d);
        //         })
        //         .on("mouseout", (event) => {
        //             clearInfo();
        //             removeLineToPrediction();
        //         });

        // }
        function plotDataPointsRegression(dataPoints, predictions, isTrainingSet, r = 5) {
            const className = isTrainingSet ? "train-point" : "val-point";
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            scatter.selectAll(`.${className}`)
                .data(dataPoints)
                .join("circle")
                .attr("class", `data-point regression ${isTrainingSet ? 'train' : 'val'}`)
                .attr("cx", d => newX(d[0]))
                .attr("cy", d => newY(d[1]))
                .attr("r", r)
                .on("mouseover", (event, d) => {
                    showDataPointInfo(event, d);
                })
                .on("mouseout", (event) => {
                    clearInfo();
                    removeLineToPrediction();
                });
        }


        function removeLineToPrediction() {
            scatter.selectAll(".prediction-line").remove();
        }


        function showDataPointInfo(event, d) {
            const [xValue, yValue] = d;
            const y_pred = w_pred * xValue + b_pred;
            const diff = (y_pred - yValue).toFixed(2)
            const loss = (diff ** 2).toFixed(2)
            const content = `**${event.target.classList.contains('train') ? 'Training' : 'Validation'}** Data Point\n
            $$(x, y) = (${xValue.toFixed(2)}, ${yValue.toFixed(2)})$$\n
            $$\\hat{y} = \\hat{w}{x} + \\hat{b} = ${w_pred.toFixed(2)}(${xValue.toFixed(2)}) + ${b_pred.toFixed(2)} = ${y_pred.toFixed(2)}$$\n
            Difference: $$\\hat{y} - {y} = ${diff}$$
            Loss: $$(\\hat{y} - {y})^2 = ${loss}$$`;
            renderInfoContent(infoElement, content);

            // Draw the line to prediction
            drawLineToPrediction(xValue, yValue, y_pred);
        }

        function showYTrueInfo(event) {
            const content = `The line representing the **true** parameters ($$ w=${w_true}, b=${b_true} $$)
            $$ y = wx + b $$\n$$ y = ${w_true}x + ${b_true}$$\n
            The full function that generates the data is:
            $$ y = ${w_true}x + ${b_true} + U(-${noiseScale},${noiseScale}) $$\n
            where $$U$$ is a function that generates a random number uniformly between $$(-${noiseScale},${noiseScale})$$ and $$x$$ is sampled between $$[${x_min}, ${x_max}]$$.`;
            renderInfoContent(infoElement, content);

            // Draw dotted lines
            // drawDottedLines();
        }

        function showYPredInfo(event) {
            const content = `The line representing our current guesses for what the parameters $$w$$ and $$b$$ should be: ($$\\hat{w}=${w_pred.toFixed(2)}, \\hat{b}=${b_pred.toFixed(2)}$$).\n
            $$ \\hat{y} = \\hat{w}x + \\hat{b} $$
            $$\\hat{y} = ${w_pred.toFixed(2)}x + ${b_pred.toFixed(2)}$$`;
            renderInfoContent(infoElement, content);
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Display detailed info top-right
        // 
        // TODO later - selectedElement logic so that a click on an el keeps it in display until next click
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function showInfo(event) {
            const target = event.target;
            let content = '';

            if (target.id === 'btn-play-pause' || target.id === "btn-play-pause-content") {
                if (isRunningOptimization) {
                    content = "Pause optimization";
                } else {
                    content = "Run optimization";
                }
            } else if (target.id === 'btn-fwd-backprop-update') {
                switch (currentTrainingStage) {
                    case 0:
                        content = "**Forward pass**: run inference/prediction on the input data to produce predictions $$\\hat{y}$$ and calculate loss with respect to the true output values $$y$$.";
                        break;
                    case 1:
                        // content = "**Backpropagate gradients**: Use the loss information to calculate gradients for each of the tunable weight parameters $$ W $$, starting at the end of the MLP and using the gradient information from later layers to calculate how much we should change the weights in the earlier layers. We are able to accomplish this using the chain rule from calculus ($$\\dfrac{dL}{dW_{l}} → \\dfrac{dL}{dW_{l-1}} → ... → \\dfrac{dL}{dW_{1}}$$, where $$l$$ is the number of layers in our MLP)";
                        content = "**Backpropagate gradients**: Use the loss information to calculate gradients for each of the tunable weight parameters $$ W $$, starting at the end of the MLP and using the gradient information from later layers to calculate how much we should change the weights in the earlier layers.\n\nWe are able to accomplish this using the chain rule from calculus.";
                        break;
                    case 2:
                        showNetworkGradients();
                        content = "**Update weights**: Use the gradient information to update the weights $$ W $$ of the network based on our optimization algorithm (AdamW in this case) and hyperparameters (e.g. learning rate, weight decay), with the goal of nudging this network towards better predictions of the output given the input.\n\nWe also zeros out the gradients to prepare for the next step.";
                        break;
                }
            } else if (target.id === 'btn-reset-mlp') {
                content = "Reset the network parameters to randomly initialized values based on the Uniform Xavier initialization.";
            } else if (target.id === 'btn-shock-weights') {
                content = `\"Shock\" the weights: perturb the weight parameters by adding a small amount of uniform random noise between $$[-${shockNoiseScale}, ${shockNoiseScale}]$$.`;
            } else if (target.id === 'btn-step') {
                content = "Run one full epoch of the training loop and show network animations illustrating the forward pass, backpropagation of gradients, and update of the weights.";
            } else if (target.id === 'btn-regen-data') {
                content = "Initialize a new network with the given dimensions.\n\nThis will reset all weights and biases to new random values based on the specified layer structure and the Uniform Xavier Initialization.";
            } else if (target.classList.contains('node')) {
                const layerIndex = parseInt(target.dataset.layer);
                const nodeIndex = parseInt(target.dataset.node);
                if (nodeIndex === layerDims[layerIndex]) {
                    content = `Identity node representing the integer $$1$$.\n\nIt provides a way to add the bias term as part of the matrix multiplication, rather than performing a seperate addition after the multiplication.`;
                } else if (layerIndex === 0) {
                    content = `Input feature: $$ x $$\n\n Represents the $$x$$ coordinate of the $$(x,y)$$ plane.\n\nWhen working with higher dimensional data, there will be an input feature for each dimension of $$ {x} $$, each with its own separate weight term.`;
                } else if (layerIndex === layerDims.length - 1) {
                    content = `Predicted output: $$\\hat{y}$$\n\nThe predicted output based on the input $$x$$ and our model parameters: $$\\hat{y} =\\hat{w}x + \\hat{b}$$.`;
                } else if (layerIndex === layerDims.length) {
                    content = `The true output $$y$$ for the given input $$x$$`;
                } else {
                    content = `Node in fully connected layer ${layerIndex}, index ${nodeIndex}`;
                }
            } else if (target.classList.contains('connection')) {
                const [fromLayer, fromNode] = target.dataset.from.split(',');
                const [toLayer, toNode] = target.dataset.to.split(',');
                const fromLayerIndex = parseInt(fromLayer);
                const toLayerIndex = parseInt(toLayer);
                const fromNodeIndex = parseInt(fromNode);
                const toNodeIndex = parseInt(toNode);


                if (fromLayerIndex === layerDims.length - 1 && toLayerIndex === layerDims.length) {
                    content = `Compare $$\\hat{y}$$ and $$y$$ at feature index ${fromNodeIndex}`;
                } else {
                    const strength = parseFloat(target.dataset.strength);
                    const gradient = parseFloat(target.dataset.gradient);
                    const absGradient = Math.abs(gradient);
                    const gradEpsilon = 0.0001;

                    let color;
                    if (gradient >= 0) {
                        color = `rgba(0, 0, 255, ${absGradient / (maxGradient + gradEpsilon)})`;
                    } else {
                        color = `rgba(255, 0, 0, ${absGradient / (maxGradient + gradEpsilon)})`;
                    }

                    target.style.filter = `drop-shadow(0 0 3px ${color})`;
                    if (strength >= 0) {
                        target.classList.add('positive');
                        target.classList.remove('negative');
                    } else {
                        target.classList.add('negative');
                        target.classList.remove('positive');
                    }
                    if (fromNodeIndex === layerDims[fromLayerIndex]) {
                        content = `Bias term: $$\\hat{b}$$\n\nRepresents our current guess for the true parameter $$b$$.\n\nStrength: $$${strength.toFixed(4)}$$`;
                    } else if (fromNodeIndex === 0) {
                        content = `Weight term: $$\\hat{w}$$\n\nRepresents our current guess for the true parameter $$w$$.\n\nStrength: $$${strength.toFixed(4)}$$`;
                    }
                    content += `\nGradient: $$${gradient.toFixed(4)}$$`;

                }
            } else if (target.classList.contains('layer') || target.parentElement.classList.contains('layer')) {
                const layer = target.classList.contains('layer') ? target : target.parentElement;
                const layerIndex = parseInt(layer.dataset.layer);
                if (layerIndex === 0) {
                    content = `Input layer: contains the input $$x$$ and an identity node $$1$$.`;
                } else if (layerIndex === layerDims.length - 1) {
                    content = `Output layer: contains the output $$\\hat{y}$$`;
                } else if (layerIndex === layerDims.length) {
                    content = `The true value $$y$$ which we will compare with $$\\hat{y}$$ to measure our loss.`;
                }
            } else if (target.closest('.latex-label')) {
                const latexLabel = target.closest('.latex-label');
                const formula = latexLabel.dataset.latex;
                let explanation = '';
                const W_mat = `\\begin{bmatrix} \\hat{w} , \\hat{b} \\end{bmatrix}`
                const X_mat = `\\begin{bmatrix} x \\\\ 1 \\end{bmatrix}`

                switch (latexLabel.dataset.info) {
                    case 'x':
                        explanation = "This represents the input to the neural network.\n\nIn this case, it's a 2D array containing the $$x1$$ and $$x2$$ coordinates of each data point.";
                        break;
                    case 'y':
                        explanation = "This is the true value $$y$$ for the given input $$x$$.";
                        break;
                    case 'y_hat':
                        explanation = `$$\\hat{y}$$ is the predicted output of the neural network.
                        We can think of $$W$$ as a linear function that maps $$x$$ to $$\\hat{y}$$: $$W(x) =\\hat{w}x + \\hat{b} = \\hat{y}$$\n
                        The actual operation that will be carried out mathematically is $$\\hat{y} = W \\cdot X = ${W_mat} \\cdot ${X_mat} = \\hat{w}x + \\hat{b} $$
                        where $$W = ${W_mat}, X = ${X_mat}$$`;
                        break;
                    case 'loss':
                        explanation = `This is the loss function, which measures the difference between the predicted output $$\\hat{y}$$ and the true label $$y$$. We use mean squared error (MSE) loss for this regression task.
                        $$ L(\\hat{y},y) = MSE(\\hat{y},y) = \\frac{1}{n} \\sum_{i=1}^{n} (\\hat{y}_i - y_i)^2$$, where $$i$$ is the index of each sample in the dataset, and $$n$$ is the total number of samples.
                        \nThe goal of training is to minimize this loss.`;
                        break;
                    default:
                        if (latexLabel.dataset.info.startsWith('W')) {
                            explanation = `This represents the weight matrix we use to map $$x$$ to $$\\hat{y}$$
                            $$W = ${W_mat}, X = ${X_mat}$$
                            $$\\hat{y} = W \\cdot X = ${W_mat} \\cdot ${X_mat} = \\hat{w}x + \\hat{b} $$\n
                            Alternatively, we can conceive of $$W$$ as a linear function that we apply to $$x$$ to get $$\\hat{y}$$: $$W(x) =\\hat{w}x + \\hat{b} = \\hat{y}$$`; 
                        } 
                }

                content = `$$${formula}$$\n\n${explanation}`;
            }



            renderInfoContent(infoElement, content);
        }


        function showReportingInfo(event) {
            const target = event.currentTarget;
            let content = '';

            function formatLossForLatex(lossValue) {
                if (lossValue === 'N/A') return 'N/A';
                const number = parseFloat(lossValue);
                if (isNaN(number)) return 'N/A';

                // Format to scientific notation with 5 decimal places
                let [coefficient, exponent] = number.toExponential(3).split('e');

                // Remove leading '+' from exponent if present
                exponent = parseInt(exponent);

                // Format for LaTeX
                return `${coefficient} \\times 10^{${exponent}}`;
            }

            if (target.id === 'epoch-display') {
                content = "An **epoch** is one complete pass through the entire training dataset. It represents a full cycle of training where the model has seen and learned from all available training examples once.";
            } else if (target.id === 'train-loss-display') {
                const trainLoss = formatLossForLatex(document.getElementById('train-loss-value').textContent);
                content = `**Training Loss**: The average loss (error) of the model on the training dataset.\n\nLower values indicate better performance on the training data.\n\nCurrent value: $$ ${trainLoss}$$`;
            } else if (target.id === 'val-loss-display') {
                const valLoss = formatLossForLatex(document.getElementById('val-loss-value').textContent);
                content = `**Validation Loss**: The average loss (error) of the model on the validation dataset.\n\nThis helps assess how well the model generalizes to unseen data.\n\nCurrent value: $$ ${valLoss}$$.`;
            }

            renderInfoContent(infoElement, content);
        }

        function showNetworkGradients() {


        }

        function clearInfo(event) {
            const defaultStr = ""; // TODO can edit this to be a general description about what we're doing

            if (!selectedElement) {
                document.getElementById('info').textContent = defaultStr;
            }
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Create figure labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // function renderLatexLabelsDataPlot() {
        //     katex.render("{w} =", document.getElementById('w-label'), {
        //         throwOnError: false,
        //         displayMode: false,
        //         fontSize: '16px'
        //     });
        //     katex.render("{b} =", document.getElementById('b-label'), {
        //         throwOnError: false,
        //         displayMode: false,
        //         fontSize: '16px'
        //     });
        // }


        function createLatexLabel(x, y, text, color, labelInfo) {
            const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            foreignObject.setAttribute('x', x - 75);
            foreignObject.setAttribute('y', y - 20);
            foreignObject.setAttribute('width', '150');
            foreignObject.setAttribute('height', '40');
            foreignObject.classList.add('latex-label');
            foreignObject.dataset.latex = text;
            foreignObject.dataset.info = labelInfo;

            const div = document.createElement('div');
            div.style.fontSize = LATEX_FONT_SIZE + 'px';
            div.style.color = color;
            div.style.display = 'flex';
            div.style.justifyContent = 'center';
            div.style.alignItems = 'center';
            div.style.height = '100%';

            katex.render(text, div, {
                throwOnError: false
            });

            foreignObject.appendChild(div);
            foreignObject.addEventListener('mouseover', showInfo);
            foreignObject.addEventListener('mouseout', clearInfo);
            foreignObject.addEventListener('click', showInfo);

            return foreignObject;
        }


        function addLayerLabels() {
            const layerGap = svgWidth / (layerDims.length + 2);

            // Input layer label
            svgNetwork.appendChild(createLatexLabel(layerGap, svgHeight - 20, '{x}', LATEX_COLOR, "x"));
            // Output layer label
            svgNetwork.appendChild(createLatexLabel(layerDims.length * layerGap, svgHeight - 20, `\\hat{{y}} = {W}({x})`, LATEX_COLOR, "y_hat"));
            // True values label
            svgNetwork.appendChild(createLatexLabel((layerDims.length + 1) * layerGap, svgHeight - 20, '{y}', LATEX_COLOR, "y"));
            // Weight labels
            svgNetwork.appendChild(createLatexLabel(1 * layerGap + layerGap / 2, 20, `W`, LATEX_COLOR, "W" + 1));
            // for (let i = 1; i < layerDims.length; i++) {
            //     svgNetwork.appendChild(createLatexLabel(i * layerGap + layerGap / 2, 20, `{W}_{${i}}`, LATEX_COLOR, "W" + i));
            // }
        }


        function addLossLabel() {
            const lastLayerX = (layerDims.length + 1) * (svgWidth / (layerDims.length + 2));
            const braceWidth = 15;
            svgNetwork.appendChild(createLatexLabel(lastLayerX + braceWidth * 1.5 + 80, svgHeight / 2, 'L(\\hat{y}, y)', LATEX_COLOR_LOSS, "loss"));
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Rendering events and helpers
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function renderInfoContent(element, content) {
            element.innerHTML = '';
            let currentIndex = 0;

            while (currentIndex < content.length) {
                if (content.startsWith('$$', currentIndex)) {
                    // LaTeX content
                    const endIndex = content.indexOf('$$', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed LaTeX at position', currentIndex);
                        break;
                    }
                    const latexContent = content.slice(currentIndex + 2, endIndex);
                    const span = document.createElement('span');
                    katex.render(latexContent, span, {
                        throwOnError: false,
                        displayMode: false
                    });
                    element.appendChild(span);
                    currentIndex = endIndex + 2;
                } else if (content.startsWith('**', currentIndex)) {
                    // Bold content
                    const endIndex = content.indexOf('**', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed bold at position', currentIndex);
                        break;
                    }
                    const boldContent = content.slice(currentIndex + 2, endIndex);
                    const strong = document.createElement('strong');
                    strong.textContent = boldContent;
                    element.appendChild(strong);
                    currentIndex = endIndex + 2;
                } else {
                    // Plain text
                    const nextSpecialChar = Math.min(
                        content.indexOf('$$', currentIndex) === -1 ? Infinity : content.indexOf('$$', currentIndex),
                        content.indexOf('**', currentIndex) === -1 ? Infinity : content.indexOf('**', currentIndex)
                    );
                    const textContent = content.slice(currentIndex, nextSpecialChar === Infinity ? undefined : nextSpecialChar);
                    const lines = textContent.split('\n');
                    lines.forEach((line, index) => {
                        element.appendChild(document.createTextNode(line));
                        if (index < lines.length - 1) {
                            element.appendChild(document.createElement('br'));
                        }
                    });
                    currentIndex = nextSpecialChar === Infinity ? content.length : nextSpecialChar;
                }
            }
        }


        function handleNodeHover(event) {

        }


        function resetConnectionHighlights() {
            // used for clearing node hover and update hover events
            // if (selectedElement) return; // Don't reset if there's a selected element
            const highlightedConnections = document.querySelectorAll('.connection.highlighted');
            highlightedConnections.forEach(conn => {
                conn.classList.remove('highlighted', 'positive', 'negative');
                conn.setAttribute('stroke-width', '1');
                conn.style.filter = '';
            });
        }


        function resetConnectionAppearance(event) {
            const target = event.target;
            if (target.classList.contains('connection')) {
                target.style.filter = '';
                target.classList.remove('highlighted', 'positive', 'negative');
            }
        }


        function updateConnectionOpacity() {
            const connections = document.querySelectorAll('.connection');
            connections.forEach(connection => {
                const strength = Math.abs(parseFloat(connection.dataset.strength));
                // const maxStrength = parseFloat(connection.dataset.maxStrength);
                const opacity = strength / maxStrength;
                connection.setAttribute('stroke-opacity', opacity);
            });
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Animations
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function animateForwardPass() {

        }

        function animateBackwardPass() {

        }



        function resetTrainingDisplay() {
            document.getElementById('epoch-display').textContent = `Epoch: N/A`;
            document.getElementById('train-loss-value').textContent = 'N/A';
            document.getElementById('val-loss-value').textContent = 'N/A';
        }


        function updateTrainingDisplay(epochVal, trainLoss, valLoss) {
            document.getElementById('epoch-display').textContent = `Epoch: ${epochVal}`;
            if (trainLoss !== null) {
                document.getElementById('train-loss-value').textContent = trainLoss.toFixed(20);
            }
            if (valLoss !== null) {
                document.getElementById('val-loss-value').textContent = valLoss.toFixed(20);
            }
        }


        function logMessage(message) {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML += `<p>${message}</p>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Random Number Generation
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        class RNG {
            constructor(seed) {
                this.state = BigInt(seed);
            }

            random_u32() {
                // xorshift rng: https://en.wikipedia.org/wiki/Xorshift#xorshift.2A
                this.state = BigInt.asUintN(64, this.state);
                this.state ^= (this.state >> 12n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state << 25n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state >> 27n) & 0xFFFFFFFFFFFFFFFFn;

                return Number((this.state * 0x2545F4914F6CDD1Dn >> 32n) & 0xFFFFFFFFn);
            }

            random() {
                // random Number in [0, 1)
                return (this.random_u32() >>> 8) / 16777216.0;
            }

            uniform(a = 0.0, b = 1.0) {
                // random Number in [a, b)
                return a + (b - a) * this.random();
            }
        }
        
        function gen_data_linear_regression(random, n = 100) {
            let pts = [];
            for (let i = 0; i < n; i++) {
                let x = random.uniform(x_min, x_max);
                let noise = random.uniform(-noiseScale, noiseScale);
                let y = w_true * x + b_true + noise
                pts.push([x, y]);
            }
            // create train/val/test splits of the data (80%, 10%, 10%)
            let tr = pts.slice(0, Math.floor(0.8 * n));
            let val = pts.slice(Math.floor(0.8 * n), Math.floor(0.9 * n));
            let te = pts.slice(Math.floor(0.9 * n));
            return [tr, val, te];
        }

        function gen_data(random, n = 100) {
            let pts = [];
            for (let i = 0; i < n; i++) {
                let x = random.uniform(-2.0, 2.0);
                let y = random.uniform(-2.0, 2.0);
                // concentric circles
                // label = 0 if x**2 + y**2 < 1 else 1 if x**2 + y**2 < 2 else 2
                // very simple dataset
                let label = x < 0 ? 0 : y < 0 ? 1 : 2;
                pts.push([[x, y], label]);
            }
            // create train/val/test splits of the data (80%, 10%, 10%)
            let tr = pts.slice(0, Math.floor(0.8 * n));
            let val = pts.slice(Math.floor(0.8 * n), Math.floor(0.9 * n));
            let te = pts.slice(Math.floor(0.9 * n));
            return [tr, val, te];
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Micrograd MLP (visual update)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function zeroGradViz() {
            const connections = document.querySelectorAll('.connection');
            connections.forEach(connection => {
                if (connection.dataset.gradient) {
                    connection.dataset.gradient = '0';
                }
                connection.style.filter = ''; // Reset any gradient-based styling
            });
        }



        function updateFwdBackUpButton(button, stage) {
            switch (stage) {
                case 0:
                    button.textContent = '→';
                    break;
                case 1:
                    button.textContent = '←';
                    break;
                case 2:
                    button.textContent = '↑';
                    break;
            }
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Micrograd MLP
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        class Value {
            // stores a single scalar value and its gradient
            constructor(data, _children = [], _op = '') {
                this.data = data;
                this.grad = 0;
                this._backward = () => { };
                this._prev = new Set(_children);
                this._op = _op;
            }

            add(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data + other.data, [this, other], '+');
                out._backward = () => {
                    this.grad += out.grad;
                    other.grad += out.grad;
                };

                return out;
            }

            mul(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data * other.data, [this, other], '*');
                out._backward = () => {
                    this.grad += other.data * out.grad;
                    other.grad += this.data * out.grad;
                };

                return out;
            }

            pow(other) {
                if (typeof other !== 'number') throw new Error("only supporting number powers for now");
                const out = new Value(Math.pow(this.data, other), [this], `**${other}`);

                out._backward = () => {
                    this.grad += other * Math.pow(this.data, other - 1) * out.grad;
                };

                return out;
            }

            relu() {
                const out = new Value(this.data < 0 ? 0 : this.data, [this], 'ReLU');
                out._backward = () => {
                    this.grad += (out.data > 0) * out.grad;
                };

                return out;
            }

            tanh() {
                const x = Math.tanh(this.data);
                const out = new Value(x, [this], 'tanh');
                out._backward = () => {
                    this.grad += (1 - x * x) * out.grad;
                };

                return out;
            }

            exp() {
                const x = Math.exp(this.data);
                const out = new Value(x, [this], 'exp');
                out._backward = () => {
                    this.grad += x * out.grad;
                };

                return out;
            }

            log() {
                const out = new Value(Math.log(this.data), [this], 'log');
                out._backward = () => {
                    this.grad += (1 / this.data) * out.grad;
                };

                return out;
            }

            backward() {
                const topo = [];
                const visited = new Set();

                function buildTopo(v) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        for (const child of v._prev) {
                            buildTopo(child);
                        }
                        topo.push(v);
                    }
                }

                buildTopo(this);

                this.grad = 1;
                for (const v of topo.reverse()) {
                    v._backward();
                }
            }

            neg() { return this.mul(-1); }
            sub(other) { return this.add(other instanceof Value ? other.neg() : new Value(-other)); }
            div(other) { return this.mul(other instanceof Value ? other.pow(-1) : new Value(Math.pow(other, -1))); }

            toString() {
                return `Value(data=${this.data}, grad=${this.grad})`;
            }
        }


        class Module {
            zeroGrad() {
                for (const p of this.parameters()) {
                    p.grad = 0;
                }
                zeroGradViz(); // update connection gradients on SVG
            }

            parameters() {
                return [];
            }
        }

        class Neuron extends Module {
            constructor(nin, kwargs) {
                super();
                this.w = Array(nin).fill().map(() => new Value(random.uniform(-1, 1) * Math.pow(nin, -0.5)));
                this.b = new Value(0);

                this.nonlin = kwargs.nonlin !== undefined ? kwargs.nonlin : true;
            }

            call(x) {
                const act = this.w.reduce((sum, wi, i) => sum.add(wi.mul(x[i])), this.b);
                return this.nonlin ? act.tanh() : act;
            }

            parameters() {
                return [...this.w, this.b];
            }

            toString() {
                return `${this.nonlin ? 'TanH' : 'Linear'}Neuron(${this.w.length})`;
            }
        }

        class Layer extends Module {
            constructor(nin, nout, kwargs = {}) {
                super();
                this.neurons = Array(nout).fill().map(() => new Neuron(nin, kwargs));
            }

            call(x) {
                const out = this.neurons.map(n => n.call(x));
                return out;
            }

            parameters() {
                return this.neurons.flatMap(n => n.parameters());
            }

            toString() {
                return `Layer of [${this.neurons.join(', ')}]`;
            }
        }

        class MLP extends Module {
            constructor(nin, nouts) {
                super();
                const sz = [nin, ...nouts];
                this.layers = sz.slice(0, -1).map((s, i) => new Layer(s, sz[i + 1], { nonlin: i !== nouts.length - 1 }));

            }

            call(x) {
                for (const layer of this.layers) {
                    x = layer.call(x);
                }
                return x
            }

            parameters() {
                return this.layers.flatMap(l => l.parameters());
            }

            toString() {
                return `MLP of [${this.layers.join(', ')}]`;
            }

            shockWeights() {
                for (const layer of this.layers) {
                    for (const neuron of layer.neurons) {
                        for (const w of neuron.w) {
                            const noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                            w.data += noise;
                        }
                        const bias_noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                        neuron.b.data += bias_noise;
                    }
                }
            }
        }

        function crossEntropy(logits, target) {
            // subtract the max for numerical stability (avoids overflow)
            const maxVal = Math.max(...logits.map(v => v.data));
            const shiftedLogits = logits.map(v => v.sub(maxVal));
            // 1) evaluate elementwise e^x
            const ex = shiftedLogits.map(x => x.exp());
            // 2) compute the sum of the above
            const denom = ex.reduce((sum, x) => sum.add(x));
            // 3) normalize by the sum to get probabilities
            const probs = ex.map(x => x.div(denom));
            // 4) log the probabilities at target
            const logp = probs[target].log();
            // 5) the negative log likelihood loss (invert so we get a loss - lower is better)
            const nll = logp.neg();
            return nll;
        }

        // evaluation utility to compute the loss on a given split of the dataset
        function evalSplit(model, split) {
            // evaluate the loss of a split
            let loss = new Value(0);
            // track for plotting
            logitsVal = [];
            predsVal = [];
            for (const [x, y] of split) {
                const logits = model.call([new Value(x[0]), new Value(x[1])]);
                logitsVal.push(logits);
                predsVal.push(argmax(logits.map(v => v.data)));
                loss = loss.add(crossEntropy(logits, y));
            }
            loss = loss.mul(1.0 / split.length); // normalize the loss
            return loss.data;
        }

        function trainForward() {
            // forward pass
            if (epoch % 10 === 0) {
                const val_loss = evalSplit(mlp, val_split);
                updateTrainingDisplay(epoch, null, val_loss);
            }

            loss = new Value(0);
            // track for plotting
            logitsTrain = [];
            predsTrain = [];
            for (const [x, y] of train_split) {
                const logits = mlp.call([new Value(x[0]), new Value(x[1])]);
                logitsTrain.push(logits);
                predsTrain.push(argmax(logits.map(v => v.data)));
                loss = loss.add(crossEntropy(logits, y));
            }
            loss = loss.mul(1.0 / train_split.length);
            updateTrainingDisplay(epoch, loss.data, null);

            updateDataPlot();
        }

        function trainBackward() {
            // backward pass (deposit the gradients)
            loss.backward();
            updatedGradViz();
        }

        function trainUpdate() {
            // update with AdamW
            for (const p of mlp.parameters()) {
                p.m = beta1 * p.m + (1 - beta1) * p.grad;
                p.v = beta2 * p.v + (1 - beta2) * Math.pow(p.grad, 2);
                const m_hat = p.m / (1 - Math.pow(beta1, epoch + 1));
                const v_hat = p.v / (1 - Math.pow(beta2, epoch + 1));
                p.data -= learning_rate * (m_hat / (Math.sqrt(v_hat) + eps) + weight_decay * p.data);
            }
            updatedStrengthViz();
            mlp.zeroGrad();
            updateTrainingDisplay(epoch, loss.data, null);

            epoch++;
        }

        function trainModelStep(stage, fullStep = false) {
            if (!mlp) {
                console.error("MLP not initialized");
                return;
            }

            if (fullStep) {
                resetCurrentTrainingStage();
                trainForward();
                trainBackward();
                trainUpdate();
            } else {
                // only animimate forward and backward passes on partial steps
                switch (stage) {
                    case 0: // Forward pass
                        trainForward();
                        animateForwardPass();
                        break;

                    case 1: // Backward pass
                        trainBackward();
                        animateBackwardPass();
                        break;
                    case 2: // Update
                        trainUpdate();
                        break;
                }
                currentTrainingStage = (stage + 1) % 3;
                updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
            }
        }

        function trainModel(state) {
            function trainingLoop() {
                if (!isRunningOptimization) return;

                trainModelStep(state, true);

                if (currentTrainingStage === 0) {
                    // We've completed a full cycle, request the next frame
                    requestAnimationFrame(trainingLoop);
                } else {
                    // We're in the middle of a cycle, continue immediately
                    trainingLoop();
                }
            }
            trainingLoop();
        }

        function resetCurrentTrainingStage() {
            // in case we are partway through a cycle, reset stage and grad
            currentTrainingStage = 0;
            mlp.zeroGrad();
            updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
        }

        function argmax(array) {
            if (array.length === 0) {
                return -1; // Return -1 for empty array
            }
            const max = Math.max(...array);
            return array.indexOf(max);
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Add event listeners and draw
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        const random = new RNG(42);

        svgNetwork.addEventListener('click', function (event) {
            showInfo(event);
        });

        function addEventListeners(element) {
            element.addEventListener('mouseover', showInfo);
            element.addEventListener('mouseout', clearInfo);
            element.addEventListener('click', showInfo);
        }

        function setInitialValues() {
            document.getElementById('w-input').value = w_true;
            document.getElementById('b-input').value = b_true;
            document.getElementById('noise-input').value = noiseScale;
        }


        document.querySelectorAll('.node, .connection, .layer, .latex-label').forEach(addEventListeners);

        document.getElementById('btn-shock-weights').addEventListener('click', function () {
            mlp.shockWeights();
            // animateShockWeights();
        });

        window.onload = function () {
            initializeD3Plot();
            // renderLatexLabelsDataPlot();
            setInitialValues();
            resetData();
            resetMLP();
        };

    </script>
</body>

</html>