<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Regression - Gradient Descent</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        #reporting-container {
            font-size: 16px;
            line-height: 1.5;
            font-family: 'Courier New', Courier, monospace;
            padding: 20px;
            width: 400px;
        }

        .loss-display {
            display: flex;
        }

        .loss-label {
            width: 250px;
        }

        #main-container {
            display: flex;
            width: 100%;
            height: 700px;
        }

        #svg-container {
            flex: 0 0 1200px;
            z-index: 10;
        }

        #right-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #info-container {
            min-height: 350px;
            padding: 15px;
            overflow: hidden;
        }

        .container {
            display: flex;
            justify-content: center;
        }

        #controls {
            padding: 0 20px;
            display: flex;
            justify-content: center;
        }

        .data-params-span {
            margin-top: 5px;
            justify-content: center;
            font-size: 16px;
        }

        #bottom-right-container {
            flex: 1;
            padding: 15px 20px;
            overflow-y: visible;
        }

        #info {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            line-height: 1.5;

            height: 250px;
            border-radius: 15px;
            /* overflow-y: auto; */
            overflow: hidden;

        }

        #info .katex {
            font-size: 1.2em;
        }

        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        /* MLP CSS*/
        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        #network {
            border: 1px solid #ccc;
        }

        .data-params-input {
            width: 35px;
            font-size: 16px;
            font-weight: 500;
            border: 0;
            background-color: rgb(240, 240, 249);
            margin: 0 4px;
        }

        .data-params-input:hover {
            outline: 1px solid navy;
        }

        .layer:hover rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.1;
        }

        .latex-label:hover {
            filter: brightness(0.5);
        }

        .latex-label.selected {
            filter: brightness(0.5);
        }

        .layer.selected>rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.3;
        }

        /* Connections */
        .connection:hover {
            stroke-width: 4;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));
        }

        .connection.positive {
            stroke: rgb(100, 100, 255);
        }

        .connection.negative {
            stroke: rgb(255, 100, 100);
        }

        .connection.selected {
            stroke-width: 3;
            stroke-opacity: 1;
        }

        /* Nodes */
        .node {
            cursor: pointer;
        }

        .node:hover {
            fill: #ffb650;
        }

        .node.selected {
            fill: #ffb650;
        }

        /* MLP actions */
        #button-group-container {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        #button-group {
            display: flex;
            align-items: center;
        }

        #button-group button {
            margin: 0 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #btn-regen-data {
            margin: 0 10px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            border: 0;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #button-group .large-button {
            font-size: 24px;
            width: 50px;
            height: 50px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
        }


        #button-group .small-button {
            font-size: 18px;
            padding: 8px 16px;
            width: 50px;
            height: 40px;
        }

        #button-group button:hover,
        #btn-regen-data:hover {
            background-color: #e0f1f2;
        }

        #button-group button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #eee;
        }

        /* Data plot */
        #data-visualization {
            margin-top: 30px;
        }

        #data-plot {
            border: 1px solid #ccc;
        }

        .data-point {
            stroke-width: 2;
            fill: none;
        }

        .data-point.hit {
            fill-opacity: 0.3;
        }

        /* .data-point.train {} */

        .data-point.val {
            stroke: #999;
            stroke-width: 2;
        }

        .regression {
            fill: navy;
        }

        .prediction-line {
            pointer-events: none;
        }

        /* github */
        .github-link {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
        }

        .github-logo {
            width: 32px;
            height: 32px;
            fill: #ccc;
            transition: fill 0.3s ease;
        }

        .github-link:hover .github-logo {
            fill: #0366d6;
        }
    </style>
    <!-- for LaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <!-- for anim -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <!-- for plotting data -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        HTML
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <div id="main-container">
        <div id="svg-container">
            <svg id="network" width="1200" height="700"></svg>
        </div>
        <div id="right-container">
            <div id="info-container">
                <div id="info"></div>
                <div id="button-group-container">
                    <div id="button-group">
                        <button id="btn-reset-mlp" class="small-button">↺</button>
                        <button id="btn-shock-weights" class="small-button">ϟ</button>
                        <button id="btn-play-pause" class="large-button">
                            <span id="btn-play-pause-content">▶</span>
                        </button>
                        <button id="btn-step" class="small-button">▶|</button>
                        <button id="btn-fwd-backprop-update" class="small-button">→</button>
                    </div>
                </div>
            </div>
            <div id="bottom-right-container">
                <div id="controls">
                    <span id="w-label" class="data-params-span">w =</span><input type="text" id="w-input"
                        class="data-params-input">
                    <span id="b-label" class="data-params-span">b =</span><input type="text" id="b-input"
                        class="data-params-input">
                    <!-- <span class="data-params-span">noise =</span><input type="text" id="noise-input" class="data-params-input"> -->
                    <button id="btn-regen-data" onclick="resetData()">Regenerate data</button>
                </div>
                <div class="container">
                    <div id="data-visualization">
                        <!-- <svg id="data-plot" width="380" height="380"></svg> -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="reporting-container">
        <div id="epoch-display">Epoch: N/A</div>
        <div id="train-loss-display" class="loss-display">
            <span class="loss-label">Training Loss:</span>
            <span id="train-loss-value">N/A</span>
        </div>
        <div id="val-loss-display" class="loss-display">
            <span class="loss-label">Validation Loss:</span>
            <span id="val-loss-value">N/A</span>
        </div>
        <div id="log-container">
            <a href="https://github.com/learn-good/mlp_viz/blob/main/1_simple_regression.html" target="_blank"
                rel="noopener noreferrer" class="github-link" title="View on GitHub">
                <svg class="github-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
                    <path fill-rule="evenodd"
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                    </path>
                </svg>
            </a>

        </div>
    </div>



    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Javascript
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <script>
        // globals
        let mlp;
        const layerDims = [1, 1];
        let train_split, val_split, test_split;
        let predsTrain, predsVal;

        let isRunningOptimization = false;
        let epoch = 0;

        let currentTrainingStage = 0; // 0: forward, 1: backward, 2: update
        let maxStrength = 0.001;
        let maxGradient = 0.001;

        // Linear Regression
        let w_hat = 1;
        let b_hat = 1;
        let w_true = -2;
        let b_true = 3;
        let sigma = 1;

        const x_min = -8
        const x_max = 8

        let learning_rate = 1e-3;

        const input_w = document.getElementById('w-input');
        const input_b = document.getElementById('b-input');
        const input_noise = document.getElementById('noise-input');
        const btn_regen_data = document.getElementById('btn-regen-data');

        const shockNoiseScale = 0.5; // Adjust this value to control the magnitude of the shock

        const btnPlayPause = document.getElementById('btn-play-pause');
        const btnShock = document.getElementById('btn-shock-weights');
        const btnStep = document.getElementById('btn-step');
        const btnResetMLP = document.getElementById('btn-reset-mlp');
        const btnFwdBackUp = document.getElementById('btn-fwd-backprop-update');

        const displayEpoch = document.getElementById('epoch-display');
        const displayTrainLoss = document.getElementById('train-loss-display');
        const displayValLoss = document.getElementById('val-loss-display');

        const infoElement = document.getElementById('info');

        let selectedElement = null;
        const svgNetwork = document.getElementById('network');

        let svgWidth = 1200;
        let svgHeight = 700;

        const valInterval = 10; // interval for calculating validation loss

        const LATEX_FONT_SIZE = 16;
        const LATEX_COLOR = '#999';
        const LATEX_COLOR_LOSS = '#666';
        const layerColors = {
            x: {
                shape: "#ccc",
                background: "rgb(250, 250, 250)"
            },
            fc: {
                shape: '#FFFFFF',
                background: "rgb(255, 255, 255)"
            },
            y: {
                shape: "#ccc",
                background: "rgb(250, 250, 250)"
            },
            bias: {
                shape: "#999",
            }
        };

        // Global variables for D3.js plot
        let svg, x, y, xAxis, yAxis, scatter;
        let currentTransform = d3.zoomIdentity;


        function getLayerColor(layerIndex) {
            if (layerIndex === 0) return layerColors.x;
            if (layerIndex === layerDims.length) return layerColors.y;
            return layerColors.fc;
        }

        function resetData() {
            w_true = parseFloat(document.getElementById('w-input').value);
            b_true = parseFloat(document.getElementById('b-input').value);

            [train_split, val_split, test_split] = gen_data_linear_regression(random, 100);
            epoch = 0;
            if (mlp) {
                checkForward();
                removeBackwardPassLabels();
                currentTrainingStage = 0;
                epoch = 0;
                // resetTrainingDisplay();
                updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
            }

            updateDataPlot();
        }

        function resetMLP() {
            mlp = new MLP(1, [1]);
            w_hat = 1;
            b_hat = 1;
            mlp.parameters()[0].data = w_hat;
            mlp.parameters()[1].data = b_hat;
            // resetAdamMLP();

            checkForward();
            currentTrainingStage = 0;
            epoch = 0;
            // resetTrainingDisplay();
            updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
            updateDataPlot();

            // Clear the existing SVG and draw the new network
            drawNetwork();
            removeBackwardPassLabels();

        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw the network
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function setMaxes() {
            if (!mlp) {
                return
            }

            const w_hat_val = mlp.parameters()[0].data;
            const b_hat_val = mlp.parameters()[1].data;
            const w_hat_grad = mlp.parameters()[0].grad;
            const b_hat_grad = mlp.parameters()[1].grad;
            maxStrength = Math.max(Math.abs(w_hat_val), Math.abs(b_hat_val));
            maxGradient = Math.max(Math.abs(w_hat_grad), Math.abs(b_hat_grad));
        }

        function drawNetwork() {
            svg.innerHTML = '';

            // Create a group for all background layers
            const layersGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgNetwork.appendChild(layersGroup);

            const nodesGroupRaised = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            const layerGap = svgWidth / (layerDims.length + 2);
            setMaxes(); // get max strength and gradient of network for drawing

            // draw layer rectangles, nodes, and connections for each layer
            const layerGroupWidth = 30;
            for (let layerIndex = 0; layerIndex < layerDims.length; layerIndex++) {
                const nodeCountNoBias = layerDims[layerIndex]

                const svgX = (layerIndex + 1) * layerGap;
                const layerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                layerGroup.classList.add('layer');
                layerGroup.dataset.layer = layerIndex;

                const layerRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                layerRect.setAttribute('x', svgX - layerGroupWidth / 2);
                layerRect.setAttribute('y', 0);
                layerRect.setAttribute('width', layerGroupWidth);
                layerRect.setAttribute('height', svgHeight);
                const layerColor = getLayerColor(layerIndex);
                layerRect.setAttribute('fill', layerColor.background);

                layerGroup.appendChild(layerRect);

                layerGroup.addEventListener('mouseover', showInfo);
                layerGroup.addEventListener('mouseout', clearInfo);

                const totalNodes = layerIndex < layerDims.length - 1 ? nodeCountNoBias + 1 : nodeCountNoBias;

                for (let i = 0; i < nodeCountNoBias; i++) {
                    const svgY = (i + 1) * (svgHeight / (totalNodes + 1));
                    if (layerIndex == 1) {
                        drawNode(svgX, svgY, layerIndex, i, nodesGroupRaised);
                    } else {
                        drawNode(svgX, svgY, layerIndex, i, layerGroup);
                    }
                }

                // Add bias node for all layers except the last one
                if (layerIndex < layerDims.length - 1) {
                    const biasY = (nodeCountNoBias + 1) * (svgHeight / (totalNodes + 1));
                    drawBiasNode(svgX, biasY, layerIndex, layerGroup);
                }

                // svgNetwork.appendChild(layerGroup);
                layersGroup.appendChild(layerGroup);

                // Draw connections
                if (layerIndex < layerDims.length - 1) {
                    drawConnections(layerIndex, svgX, layerGap);
                }
            }

            // Draw the additional "y" layer
            const yLayerX = (layerDims.length + 1) * layerGap;
            const yLayerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            yLayerGroup.classList.add('layer');
            yLayerGroup.dataset.layer = layerDims.length;

            const yLayerRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            yLayerRect.setAttribute('x', yLayerX - layerGroupWidth / 2);
            yLayerRect.setAttribute('y', 0);
            yLayerRect.setAttribute('width', layerGroupWidth);
            yLayerRect.setAttribute('height', svgHeight);
            yLayerRect.setAttribute('fill', layerColors.y.background);

            yLayerGroup.appendChild(yLayerRect);

            yLayerGroup.addEventListener('mouseover', showInfo);
            yLayerGroup.addEventListener('mouseout', clearInfo);

            const lastLayerNodeCount = layerDims[layerDims.length - 1];
            for (let i = 0; i < lastLayerNodeCount; i++) {
                const svgY = (i + 1) * (svgHeight / (lastLayerNodeCount + 1));
                drawNode(yLayerX, svgY, layerDims.length, i, yLayerGroup);
            }

            layersGroup.appendChild(yLayerGroup);

            // Draw connections between y_hat and y
            drawYConnections(layerDims.length - 1, (layerDims.length) * layerGap, layerGap);

            // Draw the curly brace and "loss" text
            const lastLayerX = (layerDims.length + 1) * layerGap;
            const braceWidth = layerGroupWidth / 2;
            const topNodeY = (1) * (svgHeight / (lastLayerNodeCount + 1));
            const bottomNodeY = (lastLayerNodeCount) * (svgHeight / (lastLayerNodeCount + 1));
            const braceHeight = bottomNodeY - topNodeY;
            const braceX = lastLayerX + layerGroupWidth;
            const braceY = topNodeY;

            const brace = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            brace.setAttribute('d', `M ${braceX} ${braceY}
                         C ${braceX} ${braceY + braceHeight * 0.05}, ${braceX + braceWidth * 0.6} ${braceY + braceHeight * 0.1}, ${braceX + braceWidth * 0.8} ${braceY + braceHeight * 0.2}
                         C ${braceX + braceWidth} ${braceY + braceHeight * 0.3}, ${braceX + braceWidth} ${braceY + braceHeight * 0.4}, ${braceX + braceWidth} ${braceY + braceHeight * 0.45}
                         L ${braceX + braceWidth * 1.5} ${braceY + braceHeight * 0.5}
                         L ${braceX + braceWidth} ${braceY + braceHeight * 0.55}
                         C ${braceX + braceWidth} ${braceY + braceHeight * 0.6}, ${braceX + braceWidth} ${braceY + braceHeight * 0.7}, ${braceX + braceWidth * 0.8} ${braceY + braceHeight * 0.8}
                         C ${braceX + braceWidth * 0.6} ${braceY + braceHeight * 0.9}, ${braceX} ${braceY + braceHeight * 0.95}, ${braceX} ${braceY + braceHeight}`);
            brace.setAttribute('fill', 'none');
            brace.setAttribute('stroke', '#ccc');
            brace.setAttribute('stroke-width', '2');
            svgNetwork.appendChild(brace);
            svgNetwork.appendChild(nodesGroupRaised);

            addLayerLabels();
            addLossLabel();
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw nodes (network)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawNode(x, y, layerIndex, nodeIndex, parent, isBiasNode = false) {
            const r = 10;
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            const shapeColor = isBiasNode ? layerColors.bias.shape : getLayerColor(layerIndex).shape
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', isBiasNode ? r / 2 : r);
            circle.setAttribute('fill', shapeColor);
            circle.setAttribute('stroke', 'gray');
            circle.setAttribute('stroke-width', '1');
            circle.classList.add('node');
            circle.dataset.layer = layerIndex;
            circle.dataset.node = nodeIndex;
            parent.appendChild(circle);

            circle.addEventListener('mouseover', showInfo);
            circle.addEventListener('mouseout', clearInfo);
            circle.addEventListener('mouseleave', resetConnectionHighlights);
        }

        function drawBiasNode(x, y, layerIndex, parent) {
            drawNode(x, y, layerIndex, layerDims[layerIndex], parent, true);
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw connections (network)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawConnections(layerIndex, layerXCoord, layerGap) {
            const currentLayer = mlp.layers[layerIndex];
            const currentLayerSize = currentLayer.neurons.length;
            const maxOpacity = 1;

            for (let i = 0; i < currentLayerSize; i++) {
                const neuron = currentLayer.neurons[i];
                let toY = (i + 1) * (svgHeight / (currentLayerSize + 2));
                if (layerIndex == layerDims.length - 2) {
                    // y_hat, no bias
                    toY = (i + 1) * (svgHeight / (currentLayerSize + 1));
                }
                // these weights project backward, meaning they describe how these neurons
                // connect to the previous layers nodes
                const neuronWeights = neuron.parameters()
                const prevLayerSize = neuronWeights.length

                for (let j = 0; j < prevLayerSize; j++) {
                    const fromY = (j + 1) * (svgHeight / (prevLayerSize + 1));
                    const weight = neuronWeights[j];

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', layerXCoord);
                    line.setAttribute('y1', fromY);
                    line.setAttribute('x2', layerXCoord + layerGap);
                    line.setAttribute('y2', toY);
                    line.setAttribute('stroke', '#999');
                    line.setAttribute('stroke-width', '1');

                    const strength = weight.data;
                    const opacity = Math.min(Math.abs(strength) / maxStrength, maxOpacity);
                    line.setAttribute('stroke-opacity', opacity);

                    line.classList.add('connection');
                    line.dataset.from = `${layerIndex},${j}`;
                    line.dataset.to = `${layerIndex + 1},${i}`;
                    line.dataset.strength = strength.toFixed(4);
                    line.dataset.gradient = weight.grad.toFixed(4);

                    svgNetwork.appendChild(line);

                    line.addEventListener('mouseover', showInfo);
                    line.addEventListener('mouseout', (event) => {
                        clearInfo(event);
                        resetConnectionAppearance(event);
                    });
                }
            }
        }


        function drawYConnections(layerIndex, x, layerGap) {
            const currentLayer = layerDims[layerIndex];

            for (let i = 0; i < currentLayer; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', (i + 1) * (svgHeight / (currentLayer + 1)));
                line.setAttribute('x2', x + layerGap);
                line.setAttribute('y2', (i + 1) * (svgHeight / (currentLayer + 1)));
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('stroke-dasharray', '5,5');

                line.classList.add('connection');
                line.dataset.from = `${layerIndex},${i}`;
                line.dataset.to = `${layerIndex + 1},${i}`;
                svgNetwork.appendChild(line);

                line.addEventListener('mouseover', showInfo);
                line.addEventListener('mouseout', clearInfo);
                line.addEventListener('click', showInfo);
            }
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw data points (d3.js)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function initializeD3Plot() {
            const margin = { top: 10, right: 30, bottom: 30, left: 60 };
            const width = 450 - margin.left - margin.right;
            const height = 380 - margin.top - margin.bottom;

            // Append the SVG object to the data-visualization div
            svg = d3.select("#data-visualization")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add X axis
            x = d3.scaleLinear()
                .domain([-15, 15])
                .range([0, width]);
            xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y axis
            y = d3.scaleLinear()
                .domain([-15, 15])
                .range([height, 0]);
            yAxis = svg.append("g")
                .call(d3.axisLeft(y));

            // Add grid line at x = 0
            svg.append("line")
                .attr("class", "grid-line vertical")
                .attr("x1", x(0))
                .attr("y1", 0)
                .attr("x2", x(0))
                .attr("y2", height)
                .attr("stroke", "#ddd")
                .attr("stroke-dasharray", "4");

            // Add grid line at y = 0
            svg.append("line")
                .attr("class", "grid-line horizontal")
                .attr("x1", 0)
                .attr("y1", y(0))
                .attr("x2", width)
                .attr("y2", y(0))
                .attr("stroke", "#ddd")
                .attr("stroke-dasharray", "4");


            // Add a clipPath to ensure that elements are only visible within a specific area
            svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            scatter = svg.append('g')
                .attr("clip-path", "url(#clip)");

            // Add zoom capabilities
            const zoom = d3.zoom()
                .scaleExtent([0.8, 10])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all") // IMPORTANT allow panning and zoom
                .style("cursor", "move")
                .lower() // IMPORTANT Move this rect to the background to capture on hover effects for data points
                .call(zoom);
        }

        function updateChart(event) {
            currentTransform = event.transform;
            // Recover new scale
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            // Update axes
            xAxis.call(d3.axisBottom(newX));
            yAxis.call(d3.axisLeft(newY));

            // Update vertical grid line (x = 0)
            svg.select(".grid-line.vertical")
                .attr("x1", newX(0))
                .attr("x2", newX(0));

            // Update horizontal grid line (y = 0)
            svg.select(".grid-line.horizontal")
                .attr("y1", newY(0))
                .attr("y2", newY(0));


            // Update circle positions
            scatter.selectAll("circle")
                .attr('cx', d => newX(d[0]))
                .attr('cy', d => newY(d[1]));

            // Update true line
            const lineData = [
                { x: newX.domain()[0], y: w_true * newX.domain()[0] + b_true },
                { x: newX.domain()[1], y: w_true * newX.domain()[1] + b_true }
            ];

            const line = d3.line()
                .x(d => newX(d.x))
                .y(d => newY(d.y));

            scatter.select(".true-line")
                .datum(lineData)
                .attr("d", line);

            // Update predicted line
            drawPredictedLine(newX, newY);


        }

        function updateDataPlot() {
            // Clear existing content
            scatter.selectAll("*").remove();

            // Plot training data
            plotDataPointsRegression(train_split, predsTrain, true);

            // Plot validation data
            plotDataPointsRegression(val_split, predsVal, false);

            // Draw the true line
            drawTrueLine();

            // Draw the predicted line
            drawPredictedLine(x, y);
        }


        function drawTrueLine() {
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            const lineData = [
                { x: newX.domain()[0], y: w_true * newX.domain()[0] + b_true },
                { x: newX.domain()[1], y: w_true * newX.domain()[1] + b_true }
            ];

            const line = d3.line()
                .x(d => newX(d.x))
                .y(d => newY(d.y));

            scatter.append("path")
                .datum(lineData)
                .attr("class", "true-line")
                .attr("fill", "none")
                .attr("stroke", "navy")
                .attr("stroke-width", 3)
                .attr("d", line)
                .on("mouseover", showYTrueInfo)
                .on("mouseout", function () {
                    clearInfo();
                    scatter.selectAll(".dotted-line").remove();
                });
        }


        function drawPredictedLine() {
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            const lineData = [
                { x: newX.domain()[0], y: w_hat * newX.domain()[0] + b_hat },
                { x: newX.domain()[1], y: w_hat * newX.domain()[1] + b_hat }
            ];

            const line = d3.line()
                .x(d => newX(d.x))
                .y(d => newY(d.y));

            scatter.selectAll(".predicted-line").remove();
            scatter.append("path")
                .datum(lineData)
                .attr("class", "predicted-line")
                .attr("fill", "none")
                .attr("stroke", "#bbb")
                .attr("stroke-width", 3)
                .attr("d", line)
                .on("mouseover", showYPredInfo)
                .on("mouseout", clearInfo);
        }

        function drawLineToPrediction(xValue, yValue, yPred) {
            // Remove any existing line
            scatter.selectAll(".prediction-line").remove();

            // Use the current transform to scale the coordinates
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            // Draw the line
            scatter.append("line")
                .attr("class", "prediction-line")
                .attr("x1", newX(xValue))
                .attr("y1", newY(yValue))
                .attr("x2", newX(xValue))
                .attr("y2", newY(yPred))
                .attr("stroke", "red")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");
        }


        function plotDataPointsRegression(dataPoints, predictions, isTrainingSet, r = 5) {
            const className = isTrainingSet ? "train-point" : "val-point";
            const newX = currentTransform.rescaleX(x);
            const newY = currentTransform.rescaleY(y);

            scatter.selectAll(`.${className}`)
                .data(dataPoints)
                .join("circle")
                .attr("class", `data-point regression ${isTrainingSet ? 'train' : 'val'}`)
                .attr("cx", d => newX(d[0]))
                .attr("cy", d => newY(d[1]))
                .attr("r", r)
                .on("mouseover", (event, d) => {
                    showDataPointInfo(event, d);
                })
                .on("mouseout", (event) => {
                    clearInfo();
                    removeLineToPrediction();
                });
        }


        function removeLineToPrediction() {
            scatter.selectAll(".prediction-line").remove();
        }


        function showDataPointInfo(event, d) {
            const [xValue, yValue] = d;
            const y_pred = w_hat * xValue + b_hat;
            const diff = (y_pred - yValue).toFixed(2)
            const loss = (diff ** 2).toFixed(2)
            const content = `**${event.target.classList.contains('train') ? 'Training' : 'Validation'}** Data Point\n
            $$(x, y) = (${xValue.toFixed(2)}, ${yValue.toFixed(2)})$$\n
            $$\\hat{y} = \\hat{w}{x} + \\hat{b} = ${w_hat.toFixed(2)}(${xValue.toFixed(2)}) + ${b_hat.toFixed(2)} = ${y_pred.toFixed(2)}$$\n
            Difference: $$\\hat{y} - {y} = ${diff}$$
            Squared Error: $$(\\hat{y} - {y})^2 = ${loss}$$`;
            renderInfoContent(infoElement, content);

            // Draw the line to prediction
            drawLineToPrediction(xValue, yValue, y_pred);
        }

        function showYTrueInfo(event) {
            const content = `The line representing the **true** parameters ($$ w=${w_true}, b=${b_true} $$)
            $$ y = wx + b $$\n$$ y = ${w_true}x + ${b_true}$$\n
            The full function that generates the data is:
            $$ y = ${w_true}x + ${b_true} + N(0,${sigma}) $$\n
            where $$N$$ is a function that generates a random number from the normal distribution with mean $$0$$ and standard deviation $$${sigma}$$, 
            and $$x$$ is sampled between $$[${x_min}, ${x_max}]$$.`;
            renderInfoContent(infoElement, content);
        }

        function showYPredInfo(event) {
            const content = `The line representing our current guesses for what the parameters $$w$$ and $$b$$ should be: ($$\\hat{w}=${w_hat.toFixed(2)}, \\hat{b}=${b_hat.toFixed(2)}$$).\n
            $$ \\hat{y} = \\hat{w}x + \\hat{b} $$
            $$\\hat{y} = ${w_hat.toFixed(2)}x + ${b_hat.toFixed(2)}$$`;
            renderInfoContent(infoElement, content);
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Display detailed info top-right
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function showInfo(event) {
            const target = event.target;
            let content = '';
            const explanation_x = `Input feature: $$ x $$\n\n This represents the $$x$$ coordinate of the $$(x,y)$$ plane.\n\nWe can also conceptualize $$x$$ as representing all of the inputs in our training set $$x_{train} = [x_1, x_2, \\cdots, x_n]$$ and operate on them in parallel.`;
            const explanation_one = `Identity node representing the scalar $$1$$.\n\nIt provides a way to add the bias term as part of the matrix multiplication, rather than performing a seperate addition after the multiplication.`;
            const params = mlp.parameters();
            const w_strength = params[0].data;
            const b_strength = params[1].data;
            const w_grad = params[0].grad;
            const b_grad = params[1].grad;
            let explanation_w_hat = `Weight term: $$\\hat{w}$$\n\nThis represents our current guess for the true parameter $$w$$.\nThis is a mutable parameter that we use to scale the input feature $$x$$.\n\nValue: $$${w_strength.toFixed(4)}$$\nGradient: $$${w_grad.toFixed(4)}$$`;
            if (Math.abs(w_grad) > 0.0001) {
                const adjustment = (-learning_rate * w_grad).toFixed(7)
                explanation_w_hat += `\nAdjustment = $$-\\alpha * \\frac{\\partial L}{\\partial \\hat{w}} = -${learning_rate} * ${w_grad.toFixed(4)} = ${adjustment} $$`
            }
            let explanation_b_hat = `Bias term: $$\\hat{b}$$\n\nThis represents our current guess for the true parameter $$b$$.\nThis is a mutable parameter that captures constant effects not explained by the input feature $$x$$.\n\nValue: $$${b_strength.toFixed(4)}$$\nGradient: $$${b_grad.toFixed(4)}$$`;
            if (Math.abs(b_grad) > 0.0001) {
                const adjustment = (-learning_rate * b_grad).toFixed(7)
                explanation_b_hat += `\nAdjustment = $$-\\alpha * \\frac{\\partial L}{\\partial \\hat{b}} = -${learning_rate} * ${b_grad.toFixed(4)} = ${adjustment} $$`
            }

            if (target.id === 'btn-play-pause' || target.id === "btn-play-pause-content") {
                if (isRunningOptimization) {
                    content = "Pause training";
                } else {
                    content = `Start training the network, running successive epochs of the cycle:\n
                    $$1)$$ Forward pass: make predictions and calculate loss.
                    $$2)$$ Backward pass: backpropagate the gradients from the loss function to the parameters.
                    $$3)$$ Update weights and zero gradients.
                    $$4)$$ Go to step 1 (start next iteration).`;
                }

            } else if (target.id === 'btn-fwd-backprop-update') {
                switch (currentTrainingStage) {
                    case 0:
                        content = "**Forward pass**: predict $$\\hat{y}$$ using our current parameters $$\\hat{w}$$ and $$\\hat{b}$$. Calculate the $$MSE$$ loss with respect to the true output values $$y$$.";
                        break;
                    case 1:
                        content = "**Backward pass**: backpropagate the gradients from the error caclulation to find the gradient of the parameters $$\\hat{w}$$ and $$\\hat{b}$$, providing us information about how the loss changes with respect to changes in the mutable parameters.";
                        break;
                    case 2:
                        content = `**Update**: based on our optimization strategy (gradient descent in our case) and hyperparameters (learning rate), make changes to out parameters $$\\hat{w}$$ and $$\\hat{b}$$, nudging them in the direction of lower loss. Zero the gradients to prepare for the next iteration.`;
                        break;
                }
            } else if (target.id === 'btn-reset-mlp') {
                content = `Reset the network parameters $$\\hat{w}$$ and $$\\hat{b}$$.`;
            } else if (target.id === 'btn-shock-weights') {
                content = `Add a small amount of uniform random noise between $$[-${shockNoiseScale}, ${shockNoiseScale}]$$ to the weight parameters.`;
            } else if (target.id === 'btn-step') {
                content = "Run one full epoch of the training loop.";
            } else if (target.id === 'btn-regen-data') {
                content = `Initialize new training and validation data sampled from:
                $$ y = wx + b + N(0,${sigma}) $$
                $$ y = ${w_true}x + ${b_true} + N(0,${sigma}) $$\n
                where $$ N(0,${sigma})$$ generates noise samples from the normal distribution with mean $$0$$ and standard deviation $$${sigma}$$.`;
            } else if (target.id == "w-input") {
                content = `Set ground truth parameter $$w$$ for the line:\n$$y = wx + b$$`;
            } else if (target.id == "b-input") {
                content = `Set ground truth parameter $$b$$ for the line:\n$$y = wx + b$$`;
            } else if (target.id == "noise-input") {
                content = `Set the standard deviation for the random normal noise $$\\sigma$$ for the function that generates the data:\n$$y = wx + b + N(0,\\sigma)$$`;
            } else if (target.classList.contains('node')) {
                const layerIndex = parseInt(target.dataset.layer);
                const nodeIndex = parseInt(target.dataset.node);
                if (nodeIndex === layerDims[layerIndex]) {
                    content = explanation_one;
                } else if (layerIndex === 0) {
                    content = explanation_x;
                } else if (layerIndex === layerDims.length - 1) {
                    content = `Predicted output: $$\\hat{y}$$\n\nThe predicted output based on the input $$x$$ and our model parameters: $$\\hat{y} =\\hat{w}x + \\hat{b}$$.`;
                } else if (layerIndex === layerDims.length) {
                    content = `The ground truth output $$y$$ for the given input $$x$$.`;
                } else {
                    content = `Node in fully connected layer ${layerIndex}, index ${nodeIndex}`;
                }
            } else if (target.classList.contains('connection')) {
                const [fromLayer, fromNode] = target.dataset.from.split(',');
                const [toLayer, toNode] = target.dataset.to.split(',');
                const fromLayerIndex = parseInt(fromLayer);
                const toLayerIndex = parseInt(toLayer);
                const fromNodeIndex = parseInt(fromNode);
                const toNodeIndex = parseInt(toNode);


                if (fromLayerIndex === layerDims.length - 1 && toLayerIndex === layerDims.length) {
                    content = `Compare $$\\hat{y}$$ and $$y$$`;
                } else {
                    const strength = parseFloat(target.dataset.strength);
                    const gradient = parseFloat(target.dataset.gradient);
                    const absGradient = Math.abs(gradient);
                    const gradEpsilon = 0.0001;

                    let color;
                    if (gradient < 0) {
                        color = `rgba(0, 0, 255, ${absGradient / (maxGradient + gradEpsilon)})`;
                    } else {
                        color = `rgba(255, 0, 0, ${absGradient / (maxGradient + gradEpsilon)})`;
                    }

                    target.style.filter = `drop-shadow(0 0 3px ${color})`;
                    if (strength >= 0) {
                        target.classList.add('positive');
                        target.classList.remove('negative');
                    } else {
                        target.classList.add('negative');
                        target.classList.remove('positive');
                    }
                    if (fromNodeIndex === layerDims[fromLayerIndex]) {
                        content = explanation_b_hat;
                    } else if (fromNodeIndex === 0) {
                        content = explanation_w_hat;
                    }

                }
            } else if (target.classList.contains('layer') || target.parentElement.classList.contains('layer')) {
                const layer = target.classList.contains('layer') ? target : target.parentElement;
                const layerIndex = parseInt(layer.dataset.layer);
                if (layerIndex === 0) {
                    content = `Input layer: contains the input $$x$$ and an identity node $$1$$.`;
                } else if (layerIndex === layerDims.length - 1) {
                    content = `Output layer: contains the output $$\\hat{y}$$`;
                } else if (layerIndex === layerDims.length) {
                    content = `The ground truth $$y$$ which we will compare with $$\\hat{y}$$ to measure our loss.`;
                }
            } else if (target.closest('.latex-label')) {
                const latexLabel = target.closest('.latex-label');
                const formula = latexLabel.dataset.latex;
                let explanation = '';
                const W_mat = `\\begin{bmatrix} \\hat{w} , \\hat{b} \\end{bmatrix}`
                const X_mat = `\\begin{bmatrix} x \\\\ 1 \\end{bmatrix}`
                const X_train = ` \\begin{bmatrix} x_1 & x_2 & \\cdots & x_n \\\\ 1 & 1 & \\cdots & 1 \\end{bmatrix}`
                const y_train = `\\begin{bmatrix} \\hat{w}x_1 + \\hat{b}, & \\hat{w}x_2 + \\hat{b}, & \\cdots , & \\hat{w}x_n + \\hat{b} \\end{bmatrix}`

                switch (latexLabel.dataset.info) {
                    case 'X':
                        explanation = `We are representing the input layer as $$ X = ${X_mat} $$, where $$x$$ is a single coordinate of the $$(x,y)$$ plane.
                        $$X_{train}$$ is a matrix containing all examples from the training set (or a random subset of examples A.K.A. a batch):
                        $$ X_{train} = ${X_train} $$
                        where $$x_1, x_2, \\ldots, x_n$$ are the individual input examples, and $$n$$ is the total number of examples in the training set (or batch). Each column represents one data point.`;
                        break;
                    case 'y':
                        explanation = `This is the true value $$y$$ for the given input $$x$$.\n
                        If we are considering the entire training set, $$y_{train} = \\begin{bmatrix} y_1, & y_2, & \\cdots , & y_n \\end{bmatrix} $$
                        `;
                        break;
                    case 'y_hat':
                        explanation = `$$\\hat{y}$$ is the predicted output of the neural network.\n
                        For a single example: $$\\hat{y} = W \\cdot X = ${W_mat} \\cdot ${X_mat} = \\hat{w}x + \\hat{b} $$\n
                        For the full training set:\n $$\\hat{y}_{train} = W \\cdot X_{train} = ${W_mat} \\cdot ${X_train} = ${y_train} $$
                        `;
                        break;
                    case 'loss':
                        explanation = `This is the loss function, which measures the difference between the predicted output $$\\hat{y}$$ and the true value $$y$$. We use mean squared error (MSE) loss for this regression task.
                        $$ L(\\hat{y},y) = MSE(\\hat{y},y) = \\frac{1}{n} \\sum_{i=1}^{n} (\\hat{y}_i - y_i)^2$$, where $$i$$ is the index of each sample in the dataset, and $$n$$ is the total number of samples.\n
                        The goal of training is to minimize this loss, bringing $$\\hat{y}$$ closer to $$y$$ by modifying the parameters $$\\hat{w}$$ and $$\\hat{b}$$ via backpropagation of error and gradient descent.`;
                        break;
                    case 'w_hat':
                        explanation = explanation_w_hat;
                        break;
                    case 'b_hat':
                        explanation = explanation_b_hat;
                        break;
                    case 'x':
                        explanation = explanation_x;
                        break;
                    case 'one':
                        explanation = explanation_one;
                        break;
                    case 'loss_expanded':
                        explanation = `This is the Mean Squared Error (MSE) loss function for a single data point:\n
                        $$ L(\\hat{y}, y) = (\\hat{y} - y)^2$$\n
                        For the entire data set:\n
                        $$MSE(\\hat{y},y) = \\frac{1}{n} \\sum_{i=1}^{n} (\\hat{y}_i - y_i)^2$$`;
                        break;

                    case 'y_hat_grad':
                        explanation = `This is the gradient of the loss with respect to $$\\hat{y}$$:\n
                        $$ \\frac{dL}{\\partial \\hat{y}} = 2(\\hat{y} - y) $$\n
                        This gradient is derived using the power rule for derivatives:\n
                        If $$f(x) = x^n$$, then $$\\frac{d}{dx}f(x) = nx^{n-1}$$\n
                        Here, $$L = (\\hat{y} - y)^2$$, so $$n=2$$, and we get $$2(\\hat{y} - y)^{2-1} = 2(\\hat{y} - y)$$.`;
                        break;

                    case 'w_hat_d1':
                        explanation = `This is the chain rule applied to find the gradient of the loss with respect to $$\\hat{w}$$:\n
                        $$ \\frac{\\partial L}{\\partial \\hat{w}} = \\frac{\\partial L}{\\partial \\hat{y}} \\cdot \\frac{\\partial \\hat{y}}{\\partial \\hat{w}} $$\n
                        We use the chain rule because $$\\hat{w}$$ affects the loss through $$\\hat{y}$$.`;
                        break;

                    case 'w_hat_d2':
                        explanation = `This is the expanded form of the gradient of the loss with respect to $$\\hat{w}$$:\n
                        $$ \\frac{\\partial L}{\\partial \\hat{w}} = 2(\\hat{y} - y) * x$$\n
                        Here, the $$x$$ comes from the product rule of derivatives. $$\\frac{\\partial \\hat{y}}{\\partial \\hat{w}} = x$$ because $$\\hat{y} = (\\hat{w}*x) + \\hat{b}$$.\n
                        For the entire data set: $$\\frac{\\partial L}{\\partial \\hat{w}} = \\frac{2}{n} \\sum_{i=1}^{n} (\\hat{y}_i - y_i) * x_i$$`;
                        break;

                    case 'update_w_hat':
                        explanation = `This is the update rule for $$\\hat{w}$$ using gradient descent:\n
                        $$ \\hat{w} := \\hat{w} - \\alpha  \\frac{\\partial L}{\\partial \\hat{w}} $$\n
                        where $$\\alpha=${learning_rate}$$ is the learning rate. This update nudges $$\\hat{w}$$ in the direction that reduces the loss.\n
                        If the learning rate $$\\alpha$$ is too large, gradient descent will not converge.`;
                        break;

                    case 'b_hat_d1':
                        explanation = `This is the chain rule applied to find the gradient of the loss with respect to $$\\hat{b}$$:\n
                        $$ \\frac{\\partial L}{\\partial \\hat{b}} = \\frac{\\partial L}{\\partial \\hat{y}} \\cdot \\frac{\\partial \\hat{y}}{\\partial \\hat{b}} $$\n
                        We use the chain rule because $$\\hat{b}$$ affects the loss through $$\\hat{y}$$.`;
                        break;

                    case 'b_hat_d2':
                        explanation = `This is the expanded form of the gradient of the loss with respect to $$\\hat{b}$$:\n
                        $$ \\frac{\\partial L}{\\partial \\hat{b}} = 2(\\hat{y} - y) * 1$$\n
                        Here, the $$1$$ comes from the product rule of derivatives. $$\\frac{\\partial \\hat{y}}{\\partial \\hat{b}} = 1$$ because $$\\hat{y} = \\hat{w}x + (\\hat{b}*1)$$.\n
                        For the entire data set: $$\\frac{\\partial L}{\\partial \\hat{b}} = \\frac{2}{n} \\sum_{i=1}^{n} (\\hat{y}_i - y_i) $$`;
                        break;

                    case 'update_b_hat':
                        explanation = `This is the update rule for $$\\hat{b}$$ using gradient descent:\n
                        $$ \\hat{b} := \\hat{b} - \\alpha  \\frac{\\partial L}{\\partial \\hat{b}} $$\n
                        where $$\\alpha=${learning_rate}$$ is the learning rate. This update nudges $$\\hat{b}$$ in the direction that reduces the loss.\n
                        If the learning rate $$\\alpha$$ is too large, gradient descent will not converge.`;
                        break;
                    default:
                        if (latexLabel.dataset.info.startsWith('W')) {
                            explanation = `This represents the weight matrix we use to map $$x$$ to $$\\hat{y}$$
                            $$W = ${W_mat}, X = ${X_mat}$$
                            $$\\hat{y} = W \\cdot X = ${W_mat} \\cdot ${X_mat} = \\hat{w}x + \\hat{b} $$`;
                            // If we instead consider $$X_{train}$$, the full training set, we get $$\\hat{y}_{train} = W \\cdot X_{train} = ${W_mat} \\cdot ${X_train} = ${y_train} $$`; 
                        }
                }

                content = explanation;
            }



            renderInfoContent(infoElement, content);
        }


        function showReportingInfo(event) {
            const target = event.currentTarget;
            let content = '';

            function formatLossForLatex(lossValue) {
                if (lossValue === 'N/A') return 'N/A';
                const number = parseFloat(lossValue);
                if (isNaN(number)) return 'N/A';

                // Format to scientific notation with 5 decimal places
                let [coefficient, exponent] = number.toExponential(3).split('e');

                // Remove leading '+' from exponent if present
                exponent = parseInt(exponent);

                // Format for LaTeX
                return `${coefficient} \\times 10^{${exponent}}`;
            }

            if (target.id === 'epoch-display') {
                content = `An **epoch** is one complete pass of learning through the entire training dataset. ` +
                    `It represents a full cycle of training where the model has seen and learned from all available training examples one time.`;
            } else if (target.id === 'train-loss-display') {
                const trainLoss = formatLossForLatex(document.getElementById('train-loss-value').textContent);
                content = `**Training Loss**: The average loss (error) of the model on the training dataset.\n\nLower values indicate better performance on the training data.\n\nCurrent value: $$ ${trainLoss}$$`;
            } else if (target.id === 'val-loss-display') {
                const valLoss = formatLossForLatex(document.getElementById('val-loss-value').textContent);
                content = `**Validation Loss**: The average loss (error) of the model on the validation dataset.\n\nThis helps assess how well the model generalizes to unseen data.\n\nCurrent value: $$ ${valLoss}$$.`;
            }

            renderInfoContent(infoElement, content);
        }

        function clearInfo(event) {
            const defaultStr = ""; // TODO can edit this to be a general description about what we're doing

            if (!selectedElement) {
                document.getElementById('info').textContent = defaultStr;
            }
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Create figure labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function renderLatexLabelsDataPlot() {
            katex.render("{w} =", document.getElementById('w-label'), {
                throwOnError: false,
                displayMode: false,
                fontSize: '16px'
            });
            katex.render("{b} =", document.getElementById('b-label'), {
                throwOnError: false,
                displayMode: false,
                fontSize: '16px'
            });
        }


        function createLatexLabel(x, y, text, color, labelInfo, width = 250, height = 40) {
            const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            foreignObject.setAttribute('x', x - (width / 2));
            foreignObject.setAttribute('y', y - 20);
            foreignObject.setAttribute('width', width);
            foreignObject.setAttribute('height', height);
            foreignObject.classList.add('latex-label');
            foreignObject.dataset.latex = text;
            foreignObject.dataset.info = labelInfo;

            const div = document.createElement('div');
            div.style.fontSize = LATEX_FONT_SIZE + 'px';
            div.style.color = color;
            div.style.display = 'flex';
            div.style.justifyContent = 'center';
            div.style.alignItems = 'center';
            div.style.height = '100%';

            katex.render(text, div, {
                throwOnError: false
            });

            foreignObject.appendChild(div);
            foreignObject.addEventListener('mouseover', showInfo);
            foreignObject.addEventListener('mouseout', clearInfo);
            foreignObject.addEventListener('click', showInfo);

            return foreignObject;
        }


        function addLayerLabels() {
            const layerGap = svgWidth / (layerDims.length + 2);

            // Input layer label
            svgNetwork.appendChild(createLatexLabel(layerGap, svgHeight - 20, 'X', LATEX_COLOR, "X", 50));
            // Output layer label
            svgNetwork.appendChild(createLatexLabel(layerDims.length * layerGap, svgHeight - 20, `\\hat{y} = W \\cdot X = \\hat{w}x + \\hat{b}`, LATEX_COLOR, "y_hat"));
            // True values label
            svgNetwork.appendChild(createLatexLabel((layerDims.length + 1) * layerGap, svgHeight - 20, 'y', LATEX_COLOR, "y"));
            // Weight labels
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 20, `W`, LATEX_COLOR, "W" + 1, 50));

            // x, 1, w_hat and b_hat
            const singleCharWidth = 15;
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 265, `\\hat{w}`, LATEX_COLOR, "w_hat", singleCharWidth));
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 380, `\\hat{b}`, LATEX_COLOR, "b_hat", singleCharWidth));
            svgNetwork.appendChild(createLatexLabel(layerGap, 200, 'x', LATEX_COLOR, "x", singleCharWidth));
            svgNetwork.appendChild(createLatexLabel(layerGap, 430, '1', LATEX_COLOR, "one", singleCharWidth));
        }

        function addLossLabel() {
            const lastLayer = (layerDims.length + 1) * (svgWidth / (layerDims.length + 2));
            const braceWidth = 15;
            svgNetwork.appendChild(createLatexLabel(lastLayer + braceWidth * 1.5 + 80, svgHeight / 2, 'L(\\hat{y}, y)', LATEX_COLOR_LOSS, "loss", 150));
        }

        function addBackwardPassLabels() {
            const layerGap = svgWidth / (layerDims.length + 2);

            // right below loss expand mse formula
            const lastLayer = (layerDims.length + 1) * (svgWidth / (layerDims.length + 2));
            const braceWidth = 15;
            svgNetwork.appendChild(createLatexLabel(lastLayer + braceWidth * 1.5 + 80,
                (svgHeight / 2) + 30, '={(\\hat{y} - y)}^2', LATEX_COLOR_LOSS, "loss_expanded", 150));

            // right below y_hat node - dL/dy_hat
            svgNetwork.appendChild(createLatexLabel(layerDims.length * layerGap, (svgHeight / 2) + 50,
                `\\dfrac{\\partial L}{\\partial \\hat{y}} = 2(\\hat{y} - y)`, LATEX_COLOR, "y_hat_grad", 180, 60));

            // right above w_hat
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 75, `\\dfrac{\\partial L}{\\partial \\hat{w}} = \\dfrac{\\partial L}{\\partial \\hat{y}} * \\dfrac{\\partial \\hat{y}}{\\partial \\hat{w}}`, LATEX_COLOR, "w_hat_d1", 250, 60));
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 135, `\\dfrac{\\partial L}{\\partial \\hat{w}} = 2(\\hat{y} - y) * x`, LATEX_COLOR, "w_hat_d2", 250, 60));
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 195, `\\hat{w} := \\hat{w} - \\alpha \\dfrac{\\partial L}{\\partial \\hat{w}}`, LATEX_COLOR, "update_w_hat", 250, 60));

            // right below b_hat
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 460, `\\dfrac{\\partial L}{\\partial \\hat{b}} = \\dfrac{\\partial L}{\\partial \\hat{y}} * \\dfrac{\\partial \\hat{y}}{\\partial \\hat{b}}`, LATEX_COLOR, "b_hat_d1", 250, 60));
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 520, `\\dfrac{\\partial L}{\\partial \\hat{b}} = 2(\\hat{y} - y) * 1`, LATEX_COLOR, "b_hat_d2", 250, 60));
            svgNetwork.appendChild(createLatexLabel(layerGap + layerGap / 2, 580, `\\hat{b} := \\hat{b} - \\alpha \\dfrac{\\partial L}{\\partial \\hat{b}}`, LATEX_COLOR, "update_b_hat", 250, 60));
        }

        function removeBackwardPassLabels() {
            const labelsQuery = `.latex-label[data-info^="loss_expanded"], .latex-label[data-info^="y_hat_grad"], 
            .latex-label[data-info^="w_hat_"], .latex-label[data-info^="b_hat_"], .latex-label[data-info^="update_"]`;
            const backwardLabels = svgNetwork.querySelectorAll(labelsQuery);
            backwardLabels.forEach(label => label.remove());
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Rendering events and helpers
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function renderInfoContent(element, content) {
            element.innerHTML = '';
            let currentIndex = 0;

            while (currentIndex < content.length) {
                if (content.startsWith('$$', currentIndex)) {
                    // LaTeX content
                    const endIndex = content.indexOf('$$', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed LaTeX at position', currentIndex);
                        break;
                    }
                    const latexContent = content.slice(currentIndex + 2, endIndex);
                    const span = document.createElement('span');
                    katex.render(latexContent, span, {
                        throwOnError: false,
                        displayMode: false
                    });
                    element.appendChild(span);
                    currentIndex = endIndex + 2;
                } else if (content.startsWith('**', currentIndex)) {
                    // Bold content
                    const endIndex = content.indexOf('**', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed bold at position', currentIndex);
                        break;
                    }
                    const boldContent = content.slice(currentIndex + 2, endIndex);
                    const strong = document.createElement('strong');
                    strong.textContent = boldContent;
                    element.appendChild(strong);
                    currentIndex = endIndex + 2;
                } else {
                    // Plain text
                    const nextSpecialChar = Math.min(
                        content.indexOf('$$', currentIndex) === -1 ? Infinity : content.indexOf('$$', currentIndex),
                        content.indexOf('**', currentIndex) === -1 ? Infinity : content.indexOf('**', currentIndex)
                    );
                    const textContent = content.slice(currentIndex, nextSpecialChar === Infinity ? undefined : nextSpecialChar);
                    const lines = textContent.split('\n');
                    lines.forEach((line, index) => {
                        element.appendChild(document.createTextNode(line));
                        if (index < lines.length - 1) {
                            element.appendChild(document.createElement('br'));
                        }
                    });
                    currentIndex = nextSpecialChar === Infinity ? content.length : nextSpecialChar;
                }
            }
        }


        function resetConnectionHighlights() {
            // used for clearing node hover and update hover events
            // if (selectedElement) return; // Don't reset if there's a selected element
            const highlightedConnections = document.querySelectorAll('.connection.highlighted');
            highlightedConnections.forEach(conn => {
                conn.classList.remove('highlighted', 'positive', 'negative');
                conn.setAttribute('stroke-width', '1');
                conn.style.filter = '';
            });
        }


        function resetConnectionAppearance(event) {
            const target = event.target;
            if (target.classList.contains('connection')) {
                target.style.filter = '';
                target.classList.remove('highlighted', 'positive', 'negative');
            }
        }


        function updateConnectionOpacity() {
            const connections = document.querySelectorAll('.connection');
            connections.forEach(connection => {
                const strength = Math.abs(parseFloat(connection.dataset.strength));
                let opacity = strength / maxStrength;
                connection.setAttribute('stroke-opacity', opacity);
            });
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Animations
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function animateForwardPass() {
            const stepDurationMs = 500;

            const animationLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgNetwork.appendChild(animationLayer);

            function isYNode(layerIndex) {
                return layerIndex === layerDims.length;
            }

            function animateLayer(layerIndex) {
                if (layerIndex > layerDims.length) {
                    svgNetwork.removeChild(animationLayer);
                    return;
                }

                const nodes = document.querySelectorAll(`.node[data-layer="${layerIndex}"]`);
                nodes.forEach(node => {
                    const animatedNode = node.cloneNode(true);
                    if (isYNode(layerIndex)) {
                        animatedNode.setAttribute('r', '7');  // Smaller radius
                        animatedNode.setAttribute('fill', '#666');  // dark navy blue color
                    } else {
                        animatedNode.setAttribute('r', '10');
                        animatedNode.setAttribute('fill', '#ffb650');
                    }
                    animatedNode.setAttribute('fill-opacity', '0');
                    animationLayer.appendChild(animatedNode);

                    anime({
                        targets: animatedNode,
                        fillOpacity: 0.7,
                        duration: stepDurationMs,
                        easing: 'easeInOutQuad'
                    });
                });

                if (layerIndex < layerDims.length) {
                    const connections = document.querySelectorAll(`.connection[data-from^="${layerIndex},"]`);
                    connections.forEach(conn => {
                        const strength = parseFloat(conn.dataset.strength);
                        const absStrength = Math.abs(strength);
                        const opacity = absStrength / maxStrength;
                        const color = strength >= 0 ? 'rgb(100, 100, 255)' : 'rgb(255, 100, 100)';

                        const animatedConn = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        animatedConn.setAttribute('x1', conn.getAttribute('x1'));
                        animatedConn.setAttribute('y1', conn.getAttribute('y1'));
                        animatedConn.setAttribute('x2', conn.getAttribute('x1'));
                        animatedConn.setAttribute('y2', conn.getAttribute('y1'));
                        animatedConn.setAttribute('stroke', color);
                        animatedConn.setAttribute('stroke-opacity', opacity);
                        animatedConn.setAttribute('stroke-width', '3');

                        // Add dashed line for connection between y_hat and y
                        if (layerIndex === layerDims.length - 1) {
                            animatedConn.setAttribute('stroke-dasharray', '5,5');
                        }

                        animationLayer.appendChild(animatedConn);

                        anime({
                            targets: animatedConn,
                            x2: conn.getAttribute('x2'),
                            y2: conn.getAttribute('y2'),
                            duration: stepDurationMs,
                            easing: 'easeInOutQuad'
                        });
                    });
                }

                setTimeout(() => animateLayer(layerIndex + 1), stepDurationMs);
            }
            animateLayer(0);
        }


        function animateBackwardPass() {
            addBackwardPassLabels();
        }


        function resetTrainingDisplay() {
            document.getElementById('epoch-display').textContent = `Epoch: N/A`;
            document.getElementById('train-loss-value').textContent = 'N/A';
            document.getElementById('val-loss-value').textContent = 'N/A';
        }


        function updateTrainingDisplay(epochVal, trainLoss, valLoss) {
            document.getElementById('epoch-display').textContent = `Epoch: ${epochVal}`;
            if (trainLoss !== null) {
                document.getElementById('train-loss-value').textContent = trainLoss.toFixed(10);
            }
            if (valLoss !== null) {
                document.getElementById('val-loss-value').textContent = valLoss.toFixed(10);
            }
        }

        function animateShockWeights() {
            setMaxes();
            const w_connection = document.querySelector('.connection[data-from="0,0"]');
            const b_connection = document.querySelector('.connection[data-from="0,1"]');

            [w_connection, b_connection].forEach(connection => {
                if (connection && connection.dataset.strength) {
                    const newStrength = parseFloat(connection.dataset.strength);

                    // Calculate new opacity
                    const opacity = Math.abs(newStrength) / maxStrength;

                    // Animate jitter effect and opacity change
                    connection.animate([
                        { transform: 'translateY(0px)' },
                        { transform: 'translateY(-5px)' },
                        { transform: 'translateY(5px)' },
                        { transform: 'translateY(0px)' }
                    ], {
                        duration: 200,
                        iterations: 1,
                        fill: 'forwards'
                    });

                    // Update the stroke-opacity attribute after animation
                    setTimeout(() => {
                        connection.setAttribute('stroke-opacity', opacity);
                    }, 200);
                }
            });

            updatedStrengthViz();
            updateConnectionOpacity();

            // Update w_hat and b_hat
            w_hat = mlp.parameters()[0].data;
            b_hat = mlp.parameters()[1].data;
            updateDataPlot();
        }



        function logMessage(message) {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML += `<p>${message}</p>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Random Number Generation
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        class RNG {
            constructor(seed) {
                this.state = BigInt(seed);
            }

            random_u32() {
                // xorshift rng: https://en.wikipedia.org/wiki/Xorshift#xorshift.2A
                this.state = BigInt.asUintN(64, this.state);
                this.state ^= (this.state >> 12n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state << 25n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state >> 27n) & 0xFFFFFFFFFFFFFFFFn;

                return Number((this.state * 0x2545F4914F6CDD1Dn >> 32n) & 0xFFFFFFFFn);
            }

            random() {
                // random Number in [0, 1)
                return (this.random_u32() >>> 8) / 16777216.0;
            }

            uniform(a = 0.0, b = 1.0) {
                // random Number in [a, b)
                return a + (b - a) * this.random();
            }

            normal(mean = 0, stddev = 1) {
                let u, v, s;
                do {
                    u = this.random() * 2 - 1;
                    v = this.random() * 2 - 1;
                    s = u * u + v * v;
                } while (s >= 1 || s == 0);

                s = Math.sqrt(-2.0 * Math.log(s) / s);
                return mean + stddev * u * s;
            }
        }

        function gen_data_linear_regression(random, n = 100) {
            let pts = [];
            for (let i = 0; i < n; i++) {
                let x = random.uniform(x_min, x_max);
                let noise = random.normal(0, sigma);
                let y = w_true * x + b_true + noise
                pts.push([x, y]);
            }
            // create train/val/test splits of the data (80%, 10%, 10%)
            let tr = pts.slice(0, Math.floor(0.8 * n));
            let val = pts.slice(Math.floor(0.8 * n), Math.floor(0.9 * n));
            let te = pts.slice(Math.floor(0.9 * n));
            return [tr, val, te];
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Micrograd MLP (visual update)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function zeroGradViz() {
            const connections = document.querySelectorAll('.connection');
            connections.forEach(connection => {
                if (connection.dataset.gradient) {
                    connection.dataset.gradient = '0';
                }
                connection.style.filter = ''; // Reset any gradient-based styling
            });
        }

        function updatedGradViz() {
            setMaxes(); // need updated maxGradient
            const connections = document.querySelectorAll('.connection');
            let layerParams = [];
            let layerSizes = [];
            mlp.layers.forEach(layer => {
                layerParams.push(layer.parameters());
                layerSizes.push(layer.neurons[0].parameters().length)
            });
            connections.forEach(connection => {
                // fromLayer determines the first index into layerParams. 
                // toNode and fromNode acts as a pointer. `n_elements_previous_layer * toNode + fromNode` gives the index
                const [fromLayer, fromNode] = connection.dataset.from.split(',').map(val => parseInt(val, 10));
                const [toLayer, toNode] = connection.dataset.to.split(',').map(val => parseInt(val, 10));

                if (fromLayer < layerParams.length) {
                    const gradient = layerParams[fromLayer][layerSizes[fromLayer] * toNode + fromNode].grad;
                    connection.dataset.gradient = gradient.toFixed(4);
                }
            });
        }

        function updatedStrengthViz() {
            setMaxes(); // need updated maxStrength
            const connections = document.querySelectorAll('.connection');
            let layerParams = [];
            let layerSizes = [];
            mlp.layers.forEach(layer => {
                layerParams.push(layer.parameters());
                layerSizes.push(layer.neurons[0].parameters().length)
            });
            connections.forEach(connection => {
                // fromLayer determines the first index into layerParams. 
                // toNode and fromNode acts as a pointer. `n_elements_previous_layer * toNode + fromNode` gives the index
                const [fromLayer, fromNode] = connection.dataset.from.split(',').map(val => parseInt(val, 10));
                const [toLayer, toNode] = connection.dataset.to.split(',').map(val => parseInt(val, 10));

                if (fromLayer < layerParams.length) {
                    const weight = layerParams[fromLayer][layerSizes[fromLayer] * toNode + fromNode].data;
                    connection.dataset.strength = weight.toFixed(4);
                }
            });
            updateConnectionOpacity();
        }

        function updateFwdBackUpButton(button, stage) {
            switch (stage) {
                case 0:
                    button.textContent = '→';
                    break;
                case 1:
                    button.textContent = '←';
                    break;
                case 2:
                    button.textContent = '↑';
                    break;
            }
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Micrograd MLP 
        // (https://github.com/EurekaLabsAI/micrograd)
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        class Value {
            // stores a single scalar value and its gradient
            constructor(data, _children = [], _op = '') {
                this.data = data;
                this.grad = 0;
                this._backward = () => { };
                this._prev = new Set(_children);
                this._op = _op;
            }

            add(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data + other.data, [this, other], '+');
                out._backward = () => {
                    this.grad += out.grad;
                    other.grad += out.grad;
                };

                return out;
            }

            mul(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data * other.data, [this, other], '*');
                out._backward = () => {
                    this.grad += other.data * out.grad;
                    other.grad += this.data * out.grad;
                };

                return out;
            }

            pow(other) {
                if (typeof other !== 'number') throw new Error("only supporting number powers for now");
                const out = new Value(Math.pow(this.data, other), [this], `**${other}`);

                out._backward = () => {
                    this.grad += other * Math.pow(this.data, other - 1) * out.grad;
                };

                return out;
            }

            relu() {
                const out = new Value(this.data < 0 ? 0 : this.data, [this], 'ReLU');
                out._backward = () => {
                    this.grad += (out.data > 0) * out.grad;
                };

                return out;
            }

            tanh() {
                const x = Math.tanh(this.data);
                const out = new Value(x, [this], 'tanh');
                out._backward = () => {
                    this.grad += (1 - x * x) * out.grad;
                };

                return out;
            }

            exp() {
                const x = Math.exp(this.data);
                const out = new Value(x, [this], 'exp');
                out._backward = () => {
                    this.grad += x * out.grad;
                };

                return out;
            }

            log() {
                const out = new Value(Math.log(this.data), [this], 'log');
                out._backward = () => {
                    this.grad += (1 / this.data) * out.grad;
                };

                return out;
            }

            backward() {
                const topo = [];
                const visited = new Set();

                function buildTopo(v) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        for (const child of v._prev) {
                            buildTopo(child);
                        }
                        topo.push(v);
                    }
                }

                buildTopo(this);

                this.grad = 1;
                for (const v of topo.reverse()) {
                    v._backward();
                }
            }

            neg() { return this.mul(-1); }
            sub(other) { return this.add(other instanceof Value ? other.neg() : new Value(-other)); }
            div(other) { return this.mul(other instanceof Value ? other.pow(-1) : new Value(Math.pow(other, -1))); }

            toString() {
                return `Value(data=${this.data}, grad=${this.grad})`;
            }
        }


        class Module {
            zeroGrad() {
                for (const p of this.parameters()) {
                    p.grad = 0;
                }
                zeroGradViz(); // update connection gradients on SVG
            }

            parameters() {
                return [];
            }
        }

        class Neuron extends Module {
            constructor(nin, kwargs) {
                super();
                // this.w = Array(nin).fill().map(() => new Value(random.uniform(-1, 1) * Math.pow(nin, -0.5)));
                this.w = Array(nin).fill().map(() => new Value(1));
                // this.b = new Value(0);
                this.b = new Value(1);

                this.nonlin = kwargs.nonlin !== undefined ? kwargs.nonlin : true;
            }

            call(x) {
                const act = this.w.reduce((sum, wi, i) => sum.add(wi.mul(x[i])), this.b);
                return this.nonlin ? act.tanh() : act;
            }

            parameters() {
                return [...this.w, this.b];
            }

            toString() {
                return `${this.nonlin ? 'TanH' : 'Linear'}Neuron(${this.w.length})`;
            }
        }

        class Layer extends Module {
            constructor(nin, nout, kwargs = {}) {
                super();
                this.neurons = Array(nout).fill().map(() => new Neuron(nin, kwargs));
            }

            call(x) {
                const out = this.neurons.map(n => n.call(x));
                return out;
            }

            parameters() {
                return this.neurons.flatMap(n => n.parameters());
            }

            toString() {
                return `Layer of [${this.neurons.join(', ')}]`;
            }
        }

        class MLP extends Module {
            constructor(nin, nouts) {
                super();
                const sz = [nin, ...nouts];
                this.layers = sz.slice(0, -1).map((s, i) => new Layer(s, sz[i + 1], { nonlin: i !== nouts.length - 1 }));
            }

            call(x) {
                for (const layer of this.layers) {
                    x = layer.call(x);
                }
                return x
            }

            parameters() {
                return this.layers.flatMap(l => l.parameters());
            }

            toString() {
                return `MLP of [${this.layers.join(', ')}]`;
            }

            shockWeights() {
                for (const layer of this.layers) {
                    for (const neuron of layer.neurons) {
                        for (const w of neuron.w) {
                            const noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                            w.data += noise;
                        }
                        const bias_noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                        neuron.b.data += bias_noise;
                    }
                }
            }
        }

        // evaluation utility to compute the loss on a given split of the dataset
        function evalSplit(model, split) {
            // evaluate the loss of a split
            let loss = new Value(0);
            for (const [x, y] of split) {
                const y_hat = mlp.call([new Value(x)])[0];
                const error = squared_error_1d(y_hat, y)
                loss = loss.add(error);
            }
            loss = loss.mul(1.0 / split.length); // normalize the loss
            return loss.data;
        }

        function squared_error_1d(y_pred, y_true) {
            return y_pred.sub(y_true).pow(2);
        }

        function trainForward() {
            // forward pass
            if (epoch % 1 === 0) {
                const val_loss = evalSplit(mlp, val_split);
                updateTrainingDisplay(epoch, null, val_loss);
            }

            loss = new Value(0);
            for (const [x, y] of train_split) {
                const y_hat = mlp.call([new Value(x)])[0];
                const error = squared_error_1d(y_hat, y)
                loss = loss.add(error);
            }
            loss = loss.mul(1.0 / train_split.length);
            updateTrainingDisplay(epoch, loss.data, null);

        }

        function checkForward() {
            const val_loss = evalSplit(mlp, val_split);
            updateTrainingDisplay(epoch, null, val_loss);

            loss = 0;
            for (const [x, y] of train_split) {
                const y_hat = mlp.call([new Value(x)])[0].data;
                loss += (y_hat - y) ** 2;
            }
            loss /= train_split.length;
            updateTrainingDisplay("N/A", loss, null);
            mlp.zeroGrad();
        }

        function trainBackward() {
            // backward pass (deposit the gradients)
            loss.backward();
            updatedGradViz();
        }

        function trainUpdate() {
            // update with gradient descent
            for (const p of mlp.parameters()) {
                p.data -= learning_rate * p.grad;
            }
            updatedStrengthViz();
            mlp.zeroGrad();
            updateTrainingDisplay(epoch, loss.data, null);

            // Update w_hat and b_hat
            w_hat = mlp.parameters()[0].data;
            b_hat = mlp.parameters()[1].data;

            updateDataPlot();

            epoch++;

        }

        function trainModelStep(stage, fullStep = false) {
            if (!mlp) {
                console.error("MLP not initialized");
                return;
            }

            if (fullStep) {
                resetCurrentTrainingStage();
                trainForward();
                trainBackward();
                trainUpdate();
            } else {
                // only animimate forward and backward passes on partial steps
                switch (stage) {
                    case 0: // Forward pass
                        trainForward();
                        animateForwardPass();
                        break;

                    case 1: // Backward pass
                        trainBackward();
                        animateBackwardPass();
                        break;
                    case 2: // Update
                        trainUpdate();
                        removeBackwardPassLabels();
                        break;
                }
                currentTrainingStage = (stage + 1) % 3;
                updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
            }
        }

        function trainModel(state) {
            function trainingLoop() {
                if (!isRunningOptimization) return;

                trainModelStep(state, true);

                if (currentTrainingStage === 0) {
                    // We've completed a full cycle, request the next frame
                    requestAnimationFrame(trainingLoop);
                } else {
                    // We're in the middle of a cycle, continue immediately
                    trainingLoop();
                }
            }
            trainingLoop();
        }

        function resetCurrentTrainingStage() {
            // in case we are partway through a cycle, reset stage and grad
            currentTrainingStage = 0;
            mlp.zeroGrad();
            updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
            removeBackwardPassLabels();
        }

        function argmax(array) {
            if (array.length === 0) {
                return -1; // Return -1 for empty array
            }
            const max = Math.max(...array);
            return array.indexOf(max);
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Add event listeners and draw
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        const random = new RNG(42);

        svgNetwork.addEventListener('click', function (event) {
            showInfo(event);
        });

        function addEventListeners(element) {
            element.addEventListener('mouseover', showInfo);
            element.addEventListener('mouseout', clearInfo);
            element.addEventListener('click', showInfo);

            // Keyboard events
            element.addEventListener('focus', showInfo);
            element.addEventListener('blur', clearInfo);
        }

        function addEventListenersReportingDisplay(element) {
            element.addEventListener('mouseover', showReportingInfo);
            element.addEventListener('mouseout', clearInfo);
            element.addEventListener('click', showReportingInfo);

            element.addEventListener('focus', showReportingInfo);
            element.addEventListener('blur', clearInfo);
        }

        function setInitialValues() {
            document.getElementById('w-input').value = w_true;
            document.getElementById('b-input').value = b_true;
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Optimization control button listeners
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        btnPlayPause.addEventListener('click', function (event) {
            isRunningOptimization = !isRunningOptimization;
            this.querySelector('span').textContent = isRunningOptimization ? '⏸' : '▶';

            if (isRunningOptimization) {
                trainModel(currentTrainingStage);
            }

            const buttonsDisableRunning = ['btn-reset-mlp', 'btn-step', 'btn-fwd-backprop-update'];
            buttonsDisableRunning.forEach(id => {
                const button = document.getElementById(id);
                button.disabled = isRunningOptimization;
            });
            showInfo(event);
        });

        btnStep.addEventListener('click', function () {
            trainModelStep(currentTrainingStage, true);
            updateFwdBackUpButton(btnFwdBackUp, currentTrainingStage);
            showInfo({ target: this });
        });

        btnFwdBackUp.addEventListener('click', function () {
            // TODO btn event handler for update
            trainModelStep(currentTrainingStage, false);
            // updateFwdBackUpButton(this, currentTrainingStage);
            showInfo({ target: this });
        });

        btnResetMLP.addEventListener('click', function () {
            resetMLP();
        });

        document.getElementById('btn-shock-weights').addEventListener('click', function () {
            mlp.shockWeights();
            animateShockWeights();
            checkForward();
        });

        addEventListeners(btnPlayPause);
        addEventListeners(btnShock);
        addEventListeners(btnStep);
        addEventListeners(btnResetMLP);
        addEventListeners(btnFwdBackUp);

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Other html element listeners
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        document.querySelectorAll('.node, .connection, .layer, .latex-label').forEach(addEventListeners);

        addEventListeners(input_w);
        addEventListeners(input_b);
        addEventListeners(btn_regen_data);

        addEventListenersReportingDisplay(displayEpoch);
        addEventListenersReportingDisplay(displayTrainLoss);
        addEventListenersReportingDisplay(displayValLoss);

        // "Main"
        window.onload = function () {
            initializeD3Plot();
            renderLatexLabelsDataPlot();
            setInitialValues();
            resetData();
            resetMLP();
            checkForward();

        };

    </script>
</body>

</html>